import {
  AWAIT_BLOCK,
  AttributeAliases,
  DYNAMIC_COMPONENT_BLOCK,
  DYNAMIC_ELEMENT_BLOCK,
  DelegatedEvents,
  EACH_BLOCK,
  EACH_INDEX_REACTIVE,
  EACH_IS_ANIMATED,
  EACH_IS_CONTROLLED,
  EACH_IS_STRICT_EQUALS,
  EACH_ITEM_BLOCK,
  EACH_ITEM_REACTIVE,
  EACH_KEYED,
  HEAD_BLOCK,
  IF_BLOCK,
  KEY_BLOCK,
  PROPS_IS_IMMUTABLE,
  PROPS_IS_LAZY_INITIAL,
  PROPS_IS_RUNES,
  PROPS_IS_UPDATED,
  PassiveDelegatedEvents,
  ROOT_BLOCK,
  SNIPPET_BLOCK,
  UNINITIALIZED,
  array_from,
  current_block,
  current_component_context,
  current_effect,
  deep_read_state,
  define_property,
  derived,
  destroy_signal,
  effect,
  execute_effect,
  flushSync,
  flush_sync,
  get,
  get_descriptor,
  get_descriptors,
  inspect_fn,
  is_array,
  is_function,
  is_signals_recorded,
  managed_effect,
  managed_pre_effect,
  mark_subtree_inert,
  mutable_source,
  namespace_svg,
  object_assign,
  pop,
  pre_effect,
  proxy,
  push,
  push_destroy_fn,
  render_effect,
  safe_equal,
  safe_not_equal,
  schedule_raf_task,
  schedule_task,
  set,
  set_ignore_mutation_validation,
  set_signal_value,
  source,
  untrack,
  user_effect
} from "./chunk-DVZZ2LBH.js";
import {
  DEV
} from "./chunk-IP2U24VQ.js";
import {
  raf
} from "./chunk-QKOF6TZO.js";
import {
  is_promise,
  noop,
  run,
  run_all,
  subscribe_to_store
} from "./chunk-LQRLXBZM.js";
import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField
} from "./chunk-6WDZWUHI.js";

// node_modules/svelte/src/internal/client/operations.js
var node_prototype;
var element_prototype;
var text_prototype;
var map_prototype = Map.prototype;
var map_set_method = map_prototype.set;
var map_get_method = map_prototype.get;
var map_delete_method = map_prototype.delete;
var append_child_method;
var clone_node_method;
var first_child_get;
var next_sibling_get;
var text_content_set;
var class_name_set;
var $window;
var $document;
function init_operations() {
  if (node_prototype !== void 0) {
    return;
  }
  node_prototype = Node.prototype;
  element_prototype = Element.prototype;
  text_prototype = Text.prototype;
  append_child_method = node_prototype.appendChild;
  clone_node_method = node_prototype.cloneNode;
  $window = window;
  $document = document;
  element_prototype.__click = void 0;
  text_prototype.__nodeValue = " ";
  element_prototype.__className = "";
  first_child_get = /** @type {(this: Node) => ChildNode | null} */
  // @ts-ignore
  get_descriptor(node_prototype, "firstChild").get;
  next_sibling_get = /** @type {(this: Node) => ChildNode | null} */
  // @ts-ignore
  get_descriptor(node_prototype, "nextSibling").get;
  text_content_set = /** @type {(this: Node, text: string ) => void} */
  // @ts-ignore
  get_descriptor(node_prototype, "textContent").set;
  class_name_set = /** @type {(this: Element, class_name: string) => void} */
  // @ts-ignore
  get_descriptor(element_prototype, "className").set;
}
function append_child(element2, child2) {
  append_child_method.call(element2, child2);
}
function map_set(map, key, value) {
  map_set_method.call(map, key, value);
}
function map_get(map, key) {
  return map_get_method.call(map, key);
}
function clone_node(node, deep) {
  return (
    /** @type {N} */
    clone_node_method.call(node, deep)
  );
}
function empty() {
  return document.createTextNode("");
}
function child(node) {
  const child2 = first_child_get.call(node);
  if (hydrating) {
    if (child2 === null) {
      const text2 = empty();
      node.appendChild(text2);
      return text2;
    } else {
      return capture_fragment_from_node(child2);
    }
  }
  return child2;
}
function child_frag(node, is_text) {
  if (hydrating) {
    const first_node = (
      /** @type {Node[]} */
      node[0]
    );
    if (is_text && (first_node == null ? void 0 : first_node.nodeType) !== 3) {
      const text2 = empty();
      current_hydration_fragment.unshift(text2);
      if (first_node) {
        first_node.parentNode.insertBefore(text2, first_node);
      }
      return text2;
    }
    if (first_node !== null) {
      return capture_fragment_from_node(first_node);
    }
    return first_node;
  }
  return first_child_get.call(
    /** @type {Node} */
    node
  );
}
function sibling(node, is_text = false) {
  const next_sibling = next_sibling_get.call(node);
  if (hydrating) {
    if (is_text && (next_sibling == null ? void 0 : next_sibling.nodeType) !== 3) {
      const text2 = empty();
      if (next_sibling) {
        const index = current_hydration_fragment.indexOf(
          /** @type {Text | Comment | Element} */
          next_sibling
        );
        current_hydration_fragment.splice(index, 0, text2);
        next_sibling.parentNode.insertBefore(text2, next_sibling);
      } else {
        current_hydration_fragment.push(text2);
      }
      return text2;
    }
    if (next_sibling !== null) {
      return capture_fragment_from_node(next_sibling);
    }
  }
  return next_sibling;
}
function set_class_name(node, class_name2) {
  class_name_set.call(node, class_name2);
}
function clear_text_content(node) {
  text_content_set.call(node, "");
}
function create_element(name) {
  return document.createElement(name);
}
function capture_fragment_from_node(node) {
  if (node.nodeType === 8 && /** @type {Comment} */
  node.data.startsWith("ssr:") && current_hydration_fragment[current_hydration_fragment.length - 1] !== node) {
    const fragment = (
      /** @type {Array<Element | Text | Comment>} */
      get_hydration_fragment(node)
    );
    const last_child = fragment[fragment.length - 1] || node;
    const target = (
      /** @type {Node} */
      last_child.nextSibling
    );
    target.$$fragment = fragment;
    return target;
  }
  return node;
}

// node_modules/svelte/src/internal/client/hydration.js
var hydrating = false;
var current_hydration_fragment = (
  /** @type {any} */
  null
);
function set_current_hydration_fragment(fragment) {
  hydrating = fragment !== null;
  current_hydration_fragment = /** @type {import('./types.js').TemplateNode[]} */
  fragment;
}
function get_hydration_fragment(node, insert_text = false) {
  const fragment = [];
  let current_node = node;
  let target_depth = null;
  while (current_node !== null) {
    const node_type = current_node.nodeType;
    const next_sibling = current_node.nextSibling;
    if (node_type === 8) {
      const data = (
        /** @type {Comment} */
        current_node.data
      );
      if (data.startsWith("ssr:")) {
        const depth = data.slice(4);
        if (target_depth === null) {
          target_depth = depth;
        } else if (depth === target_depth) {
          if (insert_text && fragment.length === 0) {
            const text2 = empty();
            fragment.push(text2);
            current_node.parentNode.insertBefore(text2, current_node);
          }
          return fragment;
        } else {
          fragment.push(
            /** @type {Text | Comment | Element} */
            current_node
          );
        }
        current_node = next_sibling;
        continue;
      }
    }
    if (target_depth !== null) {
      fragment.push(
        /** @type {Text | Comment | Element} */
        current_node
      );
    }
    current_node = next_sibling;
  }
  return null;
}
function hydrate_block_anchor(anchor_node, is_controlled) {
  if (hydrating) {
    let target_node = anchor_node;
    if (is_controlled) {
      target_node = /** @type {Node} */
      target_node.firstChild;
    }
    if (target_node.nodeType === 8) {
      let fragment = target_node.$$fragment;
      if (fragment === void 0) {
        fragment = get_hydration_fragment(target_node);
      } else {
        schedule_task(() => {
          target_node.$$fragment = void 0;
        });
      }
      set_current_hydration_fragment(fragment);
    } else {
      const first_child = (
        /** @type {Element | null} */
        target_node.firstChild
      );
      set_current_hydration_fragment(first_child === null ? [] : [first_child]);
    }
  }
}

// node_modules/svelte/src/internal/client/reconciler.js
function create_fragment_from_html(html2) {
  var elem = document.createElement("template");
  elem.innerHTML = html2;
  return elem.content;
}
function create_fragment_with_script_from_html(html2) {
  var content = create_fragment_from_html(html2);
  var scripts = content.querySelectorAll("script");
  for (const script of scripts) {
    var new_script = document.createElement("script");
    for (var i = 0; i < script.attributes.length; i++) {
      new_script.setAttribute(script.attributes[i].name, script.attributes[i].value);
    }
    new_script.textContent = script.textContent;
    script.parentNode.replaceChild(new_script, script);
  }
  return content;
}
function insert(current, parent_element, sibling2) {
  if (is_array(current)) {
    var i = 0;
    var node;
    for (; i < current.length; i++) {
      node = current[i];
      if (sibling2 === null) {
        append_child(
          /** @type {Element} */
          parent_element,
          /** @type {Node} */
          node
        );
      } else {
        sibling2.before(
          /** @type {Node} */
          node
        );
      }
    }
    return current[0];
  } else if (current !== null) {
    if (sibling2 === null) {
      append_child(
        /** @type {Element} */
        parent_element,
        /** @type {Node} */
        current
      );
    } else {
      sibling2.before(
        /** @type {Node} */
        current
      );
    }
  }
  return (
    /** @type {Text | Element | Comment} */
    current
  );
}
function remove(current) {
  var first_node = current;
  if (is_array(current)) {
    var i = 0;
    var node;
    for (; i < current.length; i++) {
      node = current[i];
      if (i === 0) {
        first_node = node;
      }
      if (node.isConnected) {
        node.remove();
      }
    }
  } else if (current.isConnected) {
    current.remove();
  }
  return (
    /** @type {Element | Comment | Text} */
    first_node
  );
}
function reconcile_html(target, value, svg) {
  hydrate_block_anchor(target);
  if (hydrating) {
    return current_hydration_fragment;
  }
  var html2 = value + "";
  var frag_nodes;
  if (svg) {
    html2 = `<svg>${html2}</svg>`;
  }
  var content = create_fragment_from_html(html2);
  if (svg) {
    content = /** @type {DocumentFragment} */
    /** @type {unknown} */
    content.firstChild;
  }
  var clone = content.cloneNode(true);
  frag_nodes = Array.from(clone.childNodes);
  frag_nodes.forEach((node) => {
    target.before(node);
  });
  return (
    /** @type {Array<Text | Comment | Element>} */
    frag_nodes
  );
}

// node_modules/svelte/src/internal/client/dom/blocks/each.js
var NEW_BLOCK = -1;
var MOVED_BLOCK = 99999999;
var LIS_BLOCK = -2;
function create_each_block(flags, anchor) {
  return {
    // anchor
    a: anchor,
    // dom
    d: null,
    // flags
    f: flags,
    // items
    v: [],
    // effect
    e: null,
    p: (
      /** @type {import('../../types.js').Block} */
      current_block
    ),
    // transition
    r: null,
    // transitions
    s: [],
    // type
    t: EACH_BLOCK
  };
}
function create_each_item_block(item, index, key) {
  return {
    // animate transition
    a: null,
    // dom
    d: null,
    // effect
    e: null,
    // index
    i: index,
    // key
    k: key,
    // item
    v: item,
    // parent
    p: (
      /** @type {import('../../types.js').EachBlock} */
      current_block
    ),
    // transition
    r: null,
    // transitions
    s: null,
    // type
    t: EACH_ITEM_BLOCK
  };
}
function each(anchor_node, collection, flags, key_fn, render_fn, fallback_fn, reconcile_fn) {
  const is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;
  const block = create_each_block(flags, anchor_node);
  let current_fallback = null;
  hydrate_block_anchor(anchor_node, is_controlled);
  let array;
  let keys = null;
  let render = null;
  let mismatch = false;
  block.r = /** @param {import('../../types.js').Transition} transition */
  (transition2) => {
    const fallback = (
      /** @type {import('../../types.js').Render} */
      current_fallback
    );
    const transitions = fallback.s;
    transitions.add(transition2);
    transition2.f(() => {
      transitions.delete(transition2);
      if (transitions.size === 0) {
        if (fallback.e !== null) {
          if (fallback.d !== null) {
            remove(fallback.d);
            fallback.d = null;
          }
          destroy_signal(fallback.e);
          fallback.e = null;
        }
      }
    });
  };
  const create_fallback_effect = () => {
    const fallback = {
      d: null,
      e: null,
      s: /* @__PURE__ */ new Set(),
      p: current_fallback
    };
    const effect2 = render_effect(
      () => {
        const dom = block.d;
        if (dom !== null) {
          remove(dom);
          block.d = null;
        }
        let anchor = block.a;
        const is_controlled2 = (block.f & EACH_IS_CONTROLLED) !== 0;
        if (is_controlled2) {
          if (!hydrating) {
            anchor = empty();
            block.a.appendChild(anchor);
          } else {
            anchor = /** @type {Comment} */
            anchor.firstChild;
          }
        }
        fallback_fn(anchor);
        fallback.d = block.d;
        block.d = null;
      },
      block,
      true
    );
    fallback.e = effect2;
    current_fallback = fallback;
  };
  const render_each = (block2) => {
    const flags2 = block2.f;
    const is_controlled2 = (flags2 & EACH_IS_CONTROLLED) !== 0;
    const anchor_node2 = block2.a;
    reconcile_fn(array, block2, anchor_node2, is_controlled2, render_fn, flags2, true, keys);
  };
  const each2 = render_effect(
    () => {
      var _a, _b;
      const maybe_array = collection();
      array = is_array(maybe_array) ? maybe_array : maybe_array == null ? [] : Array.from(maybe_array);
      if (key_fn !== null) {
        keys = array.map(key_fn);
      } else if ((flags & EACH_KEYED) === 0) {
        array.map(noop);
      }
      const length = array.length;
      if (hydrating) {
        const is_each_else_comment = (
          /** @type {Comment} */
          ((_b = (_a = current_hydration_fragment) == null ? void 0 : _a[0]) == null ? void 0 : _b.data) === "ssr:each_else"
        );
        if (is_each_else_comment && length || !is_each_else_comment && !length) {
          remove(current_hydration_fragment);
          set_current_hydration_fragment(null);
          mismatch = true;
        } else if (is_each_else_comment) {
          current_hydration_fragment.shift();
        }
      }
      if (fallback_fn !== null) {
        if (length === 0) {
          if (block.v.length !== 0 || render === null) {
            render_each(block);
            create_fallback_effect();
            return;
          }
        } else if (block.v.length === 0 && current_fallback !== null) {
          const fallback = current_fallback;
          const transitions = fallback.s;
          if (transitions.size === 0) {
            if (fallback.d !== null) {
              remove(fallback.d);
              fallback.d = null;
            }
          } else {
            trigger_transitions(transitions, "out");
          }
        }
      }
      if (render !== null) {
        execute_effect(render);
      }
    },
    block,
    false
  );
  render = render_effect(render_each, block, true);
  if (mismatch) {
    set_current_hydration_fragment([]);
  }
  push_destroy_fn(each2, () => {
    const flags2 = block.f;
    const anchor_node2 = block.a;
    const is_controlled2 = (flags2 & EACH_IS_CONTROLLED) !== 0;
    let fallback = current_fallback;
    while (fallback !== null) {
      const dom = fallback.d;
      if (dom !== null) {
        remove(dom);
      }
      const effect2 = fallback.e;
      if (effect2 !== null) {
        destroy_signal(effect2);
      }
      fallback = fallback.p;
    }
    reconcile_fn([], block, anchor_node2, is_controlled2, render_fn, flags2, false, keys);
    destroy_signal(
      /** @type {import('../../types.js').EffectSignal} */
      render
    );
  });
  block.e = each2;
}
function each_keyed(anchor_node, collection, flags, key_fn, render_fn, fallback_fn) {
  each(anchor_node, collection, flags, key_fn, render_fn, fallback_fn, reconcile_tracked_array);
}
function each_indexed(anchor_node, collection, flags, render_fn, fallback_fn) {
  each(anchor_node, collection, flags, null, render_fn, fallback_fn, reconcile_indexed_array);
}
function reconcile_indexed_array(array, each_block, dom, is_controlled, render_fn, flags, apply_transitions) {
  var a_blocks = each_block.v;
  var active_transitions = each_block.s;
  var a = a_blocks.length;
  var b = array.length;
  var length = Math.max(a, b);
  var index = 0;
  var b_blocks;
  var block;
  if (active_transitions.length !== 0) {
    destroy_active_transition_blocks(active_transitions);
  }
  if (b === 0) {
    b_blocks = [];
    if (is_controlled && a !== 0) {
      clear_text_content(dom);
    }
    while (index < length) {
      block = a_blocks[index++];
      destroy_each_item_block(block, active_transitions, apply_transitions, is_controlled);
    }
  } else {
    var item;
    let mismatch = false;
    b_blocks = Array(b);
    if (hydrating) {
      var hydration_list = (
        /** @type {import('../../types.js').TemplateNode[]} */
        current_hydration_fragment
      );
      var hydrating_node = hydration_list[0];
      for (; index < length; index++) {
        var fragment = get_hydration_fragment(hydrating_node);
        set_current_hydration_fragment(fragment);
        if (!fragment) {
          mismatch = true;
          break;
        }
        item = array[index];
        block = each_item_block(item, null, index, render_fn, flags);
        b_blocks[index] = block;
        hydrating_node = /** @type {import('../../types.js').TemplateNode} */
        /** @type {Node} */
        /** @type {Node} */
        fragment[fragment.length - 1].nextSibling.nextSibling;
      }
      remove_excess_hydration_nodes(hydration_list, hydrating_node);
    }
    for (; index < length; index++) {
      if (index >= a) {
        item = array[index];
        block = each_item_block(item, null, index, render_fn, flags);
        b_blocks[index] = block;
        insert_each_item_block(block, dom, is_controlled, null);
      } else if (index >= b) {
        block = a_blocks[index];
        destroy_each_item_block(block, active_transitions, apply_transitions);
      } else {
        item = array[index];
        block = a_blocks[index];
        b_blocks[index] = block;
        update_each_item_block(block, item, index, flags);
      }
    }
    if (mismatch) {
      set_current_hydration_fragment([]);
    }
  }
  each_block.v = b_blocks;
}
function reconcile_tracked_array(array, each_block, dom, is_controlled, render_fn, flags, apply_transitions, keys) {
  var a_blocks = each_block.v;
  const is_computed_key = keys !== null;
  var active_transitions = each_block.s;
  var a = a_blocks.length;
  var b = array.length;
  var b_blocks;
  var block;
  if (active_transitions.length !== 0) {
    destroy_active_transition_blocks(active_transitions);
  }
  if (b === 0) {
    b_blocks = [];
    if (is_controlled && a !== 0) {
      clear_text_content(dom);
    }
    while (a > 0) {
      block = a_blocks[--a];
      destroy_each_item_block(block, active_transitions, apply_transitions, is_controlled);
    }
  } else {
    var a_end = a - 1;
    var b_end = b - 1;
    var key;
    var item;
    var idx;
    let mismatch = false;
    b_blocks = Array(b);
    if (hydrating) {
      var fragment;
      var hydration_list = (
        /** @type {import('../../types.js').TemplateNode[]} */
        current_hydration_fragment
      );
      var hydrating_node = hydration_list[0];
      while (b > 0) {
        fragment = get_hydration_fragment(hydrating_node);
        set_current_hydration_fragment(fragment);
        if (!fragment) {
          mismatch = true;
          break;
        }
        idx = b_end - --b;
        item = array[idx];
        key = is_computed_key ? keys[idx] : item;
        block = each_item_block(item, key, idx, render_fn, flags);
        b_blocks[idx] = block;
        hydrating_node = /** @type {import('../../types.js').TemplateNode} */
        /** @type {Node} */
        (fragment[fragment.length - 1] || hydrating_node).nextSibling.nextSibling;
      }
      remove_excess_hydration_nodes(hydration_list, hydrating_node);
    }
    if (a === 0) {
      while (b > 0) {
        idx = b_end - --b;
        item = array[idx];
        key = is_computed_key ? keys[idx] : item;
        block = each_item_block(item, key, idx, render_fn, flags);
        b_blocks[idx] = block;
        insert_each_item_block(block, dom, is_controlled, null);
      }
    } else {
      var is_animated = (flags & EACH_IS_ANIMATED) !== 0;
      var should_update_block = (flags & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0 || is_animated;
      var start = 0;
      var sibling2 = null;
      item = array[b_end];
      key = is_computed_key ? keys[b_end] : item;
      outer:
        while (true) {
          while (a_blocks[a_end].k === key) {
            block = a_blocks[a_end--];
            item = array[b_end];
            if (should_update_block) {
              update_each_item_block(block, item, b_end, flags);
            }
            sibling2 = get_first_child(block);
            b_blocks[b_end] = block;
            if (start > --b_end || start > a_end) {
              break outer;
            }
            key = is_computed_key ? keys[b_end] : item;
          }
          item = array[start];
          key = is_computed_key ? keys[start] : item;
          while (start <= a_end && start <= b_end && a_blocks[start].k === key) {
            item = array[start];
            block = a_blocks[start];
            if (should_update_block) {
              update_each_item_block(block, item, start, flags);
            }
            b_blocks[start] = block;
            ++start;
            key = is_computed_key ? keys[start] : array[start];
          }
          break;
        }
      if (start > a_end) {
        while (b_end >= start) {
          item = array[b_end];
          key = is_computed_key ? keys[b_end] : item;
          block = each_item_block(item, key, b_end, render_fn, flags);
          b_blocks[b_end--] = block;
          sibling2 = insert_each_item_block(block, dom, is_controlled, sibling2);
        }
      } else if (start > b_end) {
        b = start;
        do {
          if ((block = a_blocks[b++]) !== null) {
            destroy_each_item_block(block, active_transitions, apply_transitions);
          }
        } while (b <= a_end);
      } else {
        var pos = 0;
        var b_length = b_end - start + 1;
        var sources = new Int32Array(b_length);
        var item_index = /* @__PURE__ */ new Map();
        for (b = 0; b < b_length; ++b) {
          a = b + start;
          sources[b] = NEW_BLOCK;
          item = array[a];
          key = is_computed_key ? keys[a] : item;
          map_set(item_index, key, a);
        }
        if (is_animated) {
          for (b = start; b <= a_end; ++b) {
            a = map_get(
              item_index,
              /** @type {V} */
              a_blocks[b].k
            );
            if (a !== void 0) {
              item = array[a];
              block = a_blocks[b];
              update_each_item_block(block, item, a, flags);
            }
          }
        }
        for (b = start; b <= a_end; ++b) {
          a = map_get(
            item_index,
            /** @type {V} */
            a_blocks[b].k
          );
          block = a_blocks[b];
          if (a !== void 0) {
            pos = pos < a ? a : MOVED_BLOCK;
            sources[a - start] = b;
            b_blocks[a] = block;
          } else if (block !== null) {
            destroy_each_item_block(block, active_transitions, apply_transitions);
          }
        }
        if (pos === MOVED_BLOCK) {
          mark_lis(sources);
        }
        var last_block;
        var last_sibling;
        var should_create;
        while (b_length-- > 0) {
          b_end = b_length + start;
          a = sources[b_length];
          should_create = a === -1;
          item = array[b_end];
          if (should_create) {
            key = is_computed_key ? keys[b_end] : item;
            block = each_item_block(item, key, b_end, render_fn, flags);
          } else {
            block = b_blocks[b_end];
            if (!is_animated && should_update_block) {
              update_each_item_block(block, item, b_end, flags);
            }
          }
          if (should_create || pos === MOVED_BLOCK && a !== LIS_BLOCK) {
            last_sibling = last_block === void 0 ? sibling2 : get_first_child(last_block);
            sibling2 = insert_each_item_block(block, dom, is_controlled, last_sibling);
          }
          b_blocks[b_end] = block;
          last_block = block;
        }
      }
    }
    if (mismatch) {
      set_current_hydration_fragment([]);
    }
  }
  each_block.v = b_blocks;
}
function remove_excess_hydration_nodes(hydration_list, next_node) {
  if (next_node === null)
    return;
  var idx = hydration_list.indexOf(next_node);
  if (idx !== -1 && hydration_list.length > idx + 1) {
    remove(hydration_list.slice(idx));
  }
}
function mark_lis(a) {
  var length = a.length;
  var parent = new Int32Array(length);
  var index = new Int32Array(length);
  var index_length = 0;
  var i = 0;
  var j;
  var k;
  var lo;
  var hi;
  for (; a[i] === NEW_BLOCK; ++i) {
  }
  index[0] = i++;
  for (; i < length; ++i) {
    k = a[i];
    if (k !== NEW_BLOCK) {
      j = index[index_length];
      if (a[j] < k) {
        parent[i] = j;
        index[++index_length] = i;
      } else {
        lo = 0;
        hi = index_length;
        while (lo < hi) {
          j = lo + hi >> 1;
          if (a[index[j]] < k) {
            lo = j + 1;
          } else {
            hi = j;
          }
        }
        if (k < a[index[lo]]) {
          if (lo > 0) {
            parent[i] = index[lo - 1];
          }
          index[lo] = i;
        }
      }
    }
  }
  j = index[index_length];
  while (index_length-- >= 0) {
    a[j] = LIS_BLOCK;
    j = parent[j];
  }
}
function insert_each_item_block(block, dom, is_controlled, sibling2) {
  var current = (
    /** @type {import('../../types.js').TemplateNode} */
    block.d
  );
  if (sibling2 === null) {
    if (is_controlled) {
      return insert(
        current,
        /** @type {Element} */
        dom,
        null
      );
    } else {
      return insert(
        current,
        /** @type {Element} */
        dom.parentNode,
        dom
      );
    }
  }
  return insert(current, null, sibling2);
}
function get_first_child(block) {
  var current = block.d;
  if (is_array(current)) {
    return (
      /** @type {Text | Element | Comment} */
      current[0]
    );
  }
  return (
    /** @type {Text | Element | Comment} */
    current
  );
}
function destroy_active_transition_blocks(active_transitions) {
  var length = active_transitions.length;
  if (length > 0) {
    var i = 0;
    var block;
    var transition2;
    for (; i < length; i++) {
      block = active_transitions[i];
      transition2 = block.r;
      if (transition2 !== null) {
        block.r = null;
        destroy_each_item_block(block, null, false);
      }
    }
    active_transitions.length = 0;
  }
}
function get_first_element(block) {
  const current = block.d;
  if (is_array(current)) {
    for (let i = 0; i < current.length; i++) {
      const node = current[i];
      if (node.nodeType !== 8) {
        return node;
      }
    }
  }
  return (
    /** @type {Text | Element | Comment} */
    current
  );
}
function update_each_item_block(block, item, index, type) {
  const block_v = block.v;
  if ((type & EACH_ITEM_REACTIVE) !== 0) {
    set_signal_value(block_v, item);
  }
  const transitions = block.s;
  const index_is_reactive = (type & EACH_INDEX_REACTIVE) !== 0;
  const each_animation = block.a;
  if (transitions !== null && (type & EACH_KEYED) !== 0 && each_animation !== null) {
    each_animation(block, transitions);
  }
  if (index_is_reactive) {
    set_signal_value(
      /** @type {import('../../types.js').Signal<number>} */
      block.i,
      index
    );
  } else {
    block.i = index;
  }
}
function destroy_each_item_block(block, transition_block, apply_transitions, controlled = false) {
  const transitions = block.s;
  if (apply_transitions && transitions !== null) {
    for (let other of transitions) {
      if (other.r === "key") {
        transitions.delete(other);
      }
    }
    if (transitions.size === 0) {
      block.s = null;
    } else {
      trigger_transitions(transitions, "out");
      if (transition_block !== null) {
        transition_block.push(block);
      }
      return;
    }
  }
  const dom = block.d;
  if (!controlled && dom !== null) {
    remove(dom);
  }
  destroy_signal(
    /** @type {import('../../types.js').EffectSignal} */
    block.e
  );
}
function each_item_block(item, key, index, render_fn, flags) {
  const each_item_not_reactive = (flags & EACH_ITEM_REACTIVE) === 0;
  const item_value = each_item_not_reactive ? item : (flags & EACH_IS_STRICT_EQUALS) !== 0 ? source(item) : mutable_source(item);
  const index_value = (flags & EACH_INDEX_REACTIVE) === 0 ? index : source(index);
  const block = create_each_item_block(item_value, index_value, key);
  const effect2 = render_effect(
    /** @param {import('../../types.js').EachItemBlock} block */
    (block2) => {
      render_fn(null, block2.v, block2.i);
    },
    block,
    true
  );
  block.e = effect2;
  return block;
}

// node_modules/svelte/src/internal/client/transitions.js
var active_tick_animations = /* @__PURE__ */ new Set();
var DELAY_NEXT_TICK = Number.MIN_SAFE_INTEGER;
var active_tick_ref = void 0;
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  const e = document.createEvent("CustomEvent");
  e.initCustomEvent(type, bubbles, cancelable, detail);
  return e;
}
function dispatch_event(dom, type) {
  dom.dispatchEvent(custom_event(type));
}
function css_style_from_camel_case(style2) {
  const parts = style2.split("-");
  if (parts.length === 1)
    return parts[0];
  return parts[0] + parts.slice(1).map(
    /** @param {any} word */
    (word) => word[0].toUpperCase() + word.slice(1)
  ).join("");
}
function css_to_keyframe(css) {
  const keyframe = {};
  const parts = css.split(";");
  for (const part of parts) {
    const [property, value] = part.split(":");
    if (!property || value === void 0)
      break;
    const formatted_property = css_style_from_camel_case(property.trim());
    keyframe[formatted_property] = value.trim();
  }
  return keyframe;
}
var _tick_fn, _duration, _current, _delay, _previous, _reversed, _delay_current, _delayed_reverse, _reverse, reverse_fn;
var TickAnimation = class {
  /**
   * @param {(t: number, u: number) => string} tick_fn
   * @param {number} duration
   * @param {number} delay
   * @param {boolean} out
   */
  constructor(tick_fn, duration, delay, out2) {
    __privateAdd(this, _reverse);
    /** @type {null | (() => void)} */
    __publicField(this, "onfinish");
    /** @type {(t: number, u: number) => string} */
    __privateAdd(this, _tick_fn, void 0);
    /** @type {number} */
    __privateAdd(this, _duration, void 0);
    /** @type {number} */
    __privateAdd(this, _current, void 0);
    /** @type {number} */
    __privateAdd(this, _delay, void 0);
    /** @type {number} */
    __privateAdd(this, _previous, void 0);
    /** @type {boolean} */
    __publicField(this, "paused");
    /** @type {boolean} */
    __privateAdd(this, _reversed, void 0);
    /** @type {number} */
    __privateAdd(this, _delay_current, void 0);
    /** @type {boolean} */
    __privateAdd(this, _delayed_reverse, void 0);
    __privateSet(this, _duration, duration);
    __privateSet(this, _delay, delay);
    this.paused = false;
    __privateSet(this, _tick_fn, tick_fn);
    __privateSet(this, _reversed, out2);
    __privateSet(this, _delay_current, delay);
    __privateSet(this, _current, out2 ? duration : 0);
    __privateSet(this, _previous, 0);
    __privateSet(this, _delayed_reverse, false);
    this.onfinish = null;
    if (__privateGet(this, _delay)) {
      if (!out2) {
        __privateGet(this, _tick_fn).call(this, 0, 1);
      }
    }
  }
  pause() {
    this.paused = true;
  }
  play() {
    this.paused = false;
    if (!active_tick_animations.has(this)) {
      __privateSet(this, _previous, raf.now());
      if (active_tick_ref === void 0) {
        active_tick_ref = raf.tick(handle_raf);
      }
      active_tick_animations.add(this);
    }
  }
  reverse() {
    if (__privateGet(this, _delay) === 0) {
      __privateMethod(this, _reverse, reverse_fn).call(this);
    } else {
      __privateSet(this, _delay_current, __privateGet(this, _delay));
      __privateSet(this, _delayed_reverse, true);
    }
  }
  cancel() {
    active_tick_animations.delete(this);
    const current = __privateGet(this, _current) / __privateGet(this, _duration);
    if (current > 0 && current < 1) {
      const t = __privateGet(this, _reversed) ? 1 : 0;
      __privateGet(this, _tick_fn).call(this, t, 1 - t);
    }
  }
  finish() {
    active_tick_animations.delete(this);
    if (this.onfinish) {
      this.onfinish();
    }
  }
  /** @param {number} time */
  _update(time) {
    let diff = time - __privateGet(this, _previous);
    __privateSet(this, _previous, time);
    if (__privateGet(this, _delay_current) !== 0) {
      const is_delayed = __privateGet(this, _delay_current) === DELAY_NEXT_TICK;
      let cancel = !__privateGet(this, _delayed_reverse);
      __privateSet(this, _delay_current, __privateGet(this, _delay_current) - diff);
      if (__privateGet(this, _delay_current) < 0 || is_delayed || __privateGet(this, _delay_current) === 0 && __privateGet(this, _reversed)) {
        const delay_diff = is_delayed ? 0 : -__privateGet(this, _delay_current);
        __privateSet(this, _delay_current, 0);
        if (__privateGet(this, _delayed_reverse)) {
          __privateSet(this, _delayed_reverse, false);
          __privateMethod(this, _reverse, reverse_fn).call(this);
        } else if (delay_diff !== 0 || __privateGet(this, _reversed)) {
          diff = delay_diff;
        }
        cancel = false;
      } else if (__privateGet(this, _delay_current) === 0) {
        __privateSet(this, _delay_current, DELAY_NEXT_TICK);
      }
      if (cancel) {
        return;
      }
    }
    __privateSet(this, _current, __privateGet(this, _current) + (__privateGet(this, _reversed) ? -diff : diff));
    let t = __privateGet(this, _current) / __privateGet(this, _duration);
    if (t < 0) {
      t = 0;
    } else if (t > 1) {
      t = 1;
    }
    if (__privateGet(this, _reversed) && t <= 0 || !__privateGet(this, _reversed) && t >= 1) {
      t = __privateGet(this, _reversed) ? 0 : 1;
      if (__privateGet(this, _delay_current) === 0) {
        active_tick_animations.delete(this);
        if (this.onfinish) {
          this.paused = true;
          this.onfinish();
        }
      }
    }
    __privateGet(this, _tick_fn).call(this, t, 1 - t);
  }
};
_tick_fn = new WeakMap();
_duration = new WeakMap();
_current = new WeakMap();
_delay = new WeakMap();
_previous = new WeakMap();
_reversed = new WeakMap();
_delay_current = new WeakMap();
_delayed_reverse = new WeakMap();
_reverse = new WeakSet();
reverse_fn = function() {
  __privateSet(this, _reversed, !__privateGet(this, _reversed));
  if (this.paused) {
    if (__privateGet(this, _current) === 0) {
      __privateSet(this, _current, __privateGet(this, _duration));
    }
    this.play();
  }
};
function handle_raf(time) {
  for (const animation of active_tick_animations) {
    if (!animation.paused) {
      animation._update(time);
    }
  }
  if (active_tick_animations.size !== 0) {
    active_tick_ref = raf.tick(handle_raf);
  } else {
    active_tick_ref = void 0;
  }
}
function create_keyframes(easing_fn, css_fn, duration, direction, reverse) {
  const keyframes = [];
  const frame_time = 16.666;
  const max_duration = Math.max(duration, frame_time);
  for (let i = 0; i <= max_duration; i += frame_time) {
    let time;
    if (i + frame_time > max_duration) {
      time = 1;
    } else if (i === 0) {
      time = 0;
    } else {
      time = i / max_duration;
    }
    let t = easing_fn(time);
    if (reverse) {
      t = 1 - t;
    }
    keyframes.push(css_to_keyframe(css_fn(t, 1 - t)));
  }
  if (direction === "out" || reverse) {
    keyframes.reverse();
  }
  return keyframes;
}
var linear = (t) => t;
function create_transition(dom, init2, direction, effect2) {
  let curr_direction = "in";
  let subs = [];
  let animation = null;
  let cancelled = false;
  const create_animation = () => {
    let payload = (
      /** @type {import('./types.js').TransitionPayload} */
      transition2.p
    );
    if (typeof payload === "function") {
      payload = payload({ direction: curr_direction });
    }
    if (payload == null) {
      return;
    }
    const duration = payload.duration ?? 300;
    const delay = payload.delay ?? 0;
    const css_fn = payload.css;
    const tick_fn = payload.tick;
    const easing_fn = payload.easing || linear;
    if (typeof tick_fn === "function") {
      animation = new TickAnimation(tick_fn, duration, delay, direction === "out");
    } else {
      const keyframes = typeof css_fn === "function" ? create_keyframes(easing_fn, css_fn, duration, direction, false) : [];
      animation = dom.animate(keyframes, {
        duration,
        endDelay: delay,
        delay,
        fill: "both"
      });
    }
    animation.pause();
    animation.onfinish = () => {
      const is_outro = curr_direction === "out";
      animation.cancel();
      if (is_outro) {
        run_all(subs);
        subs = [];
      }
      dispatch_event(dom, is_outro ? "outroend" : "introend");
    };
  };
  const transition2 = {
    e: effect2,
    i: init2,
    // payload
    p: null,
    // finished
    /** @param {() => void} fn */
    f(fn) {
      subs.push(fn);
    },
    in() {
      const needs_reverse = curr_direction !== "in";
      curr_direction = "in";
      if (animation === null || cancelled) {
        cancelled = false;
        create_animation();
      }
      if (animation === null) {
        transition2.x();
      } else {
        dispatch_event(dom, "introstart");
        if (needs_reverse) {
          animation.reverse();
        }
        animation.play();
      }
    },
    // out
    o() {
      const has_keyed_transition = dom.__animate;
      if (has_keyed_transition) {
        const style2 = getComputedStyle(dom);
        const position = style2.position;
        if (position !== "absolute" && position !== "fixed") {
          const { width, height } = style2;
          const a = dom.getBoundingClientRect();
          dom.style.position = "absolute";
          dom.style.width = width;
          dom.style.height = height;
          const b = dom.getBoundingClientRect();
          if (a.left !== b.left || a.top !== b.top) {
            const translate = `translate(${a.left - b.left}px, ${a.top - b.top}px)`;
            const existing_transform = style2.transform;
            if (existing_transform === "none") {
              dom.style.transform = translate;
            } else {
              const transform = existing_transform.startsWith("matrix(1,") ? translate : `matrix(1,0,0,1,0,0)`;
              const frame = {
                transform
              };
              const animation2 = dom.animate([frame, frame], { duration: 1 });
              animation2.pause();
            }
          }
        }
      }
      const needs_reverse = direction === "both" && curr_direction !== "out";
      curr_direction = "out";
      if (animation === null || cancelled) {
        cancelled = false;
        create_animation();
      }
      if (animation === null) {
        transition2.x();
      } else {
        dispatch_event(dom, "outrostart");
        if (needs_reverse) {
          const payload = transition2.p;
          const current_animation = (
            /** @type {Animation} */
            animation
          );
          if (payload !== null && payload.css !== void 0 && current_animation.playState === "idle") {
            const duration = payload.duration ?? 300;
            const css_fn = payload.css;
            const easing_fn = payload.easing || linear;
            const keyframes = create_keyframes(easing_fn, css_fn, duration, direction, true);
            const effect3 = current_animation.effect;
            if (effect3 !== null) {
              effect3.setKeyframes(keyframes);
            }
          }
          animation.reverse();
        } else {
          animation.play();
        }
      }
    },
    // cancel
    c() {
      if (animation !== null) {
        animation.cancel();
      }
      cancelled = true;
    },
    // cleanup
    x() {
      run_all(subs);
      subs = [];
    },
    r: direction,
    d: dom
  };
  return transition2;
}
function is_transition_block(block) {
  const type = block.t;
  return type === IF_BLOCK || type === EACH_ITEM_BLOCK || type === KEY_BLOCK || type === AWAIT_BLOCK || type === DYNAMIC_COMPONENT_BLOCK || type === EACH_BLOCK && block.v.length === 0;
}
function bind_transition(dom, get_transition_fn, props_fn, direction, global) {
  const transition_effect = (
    /** @type {import('./types.js').EffectSignal} */
    current_effect
  );
  const block = current_block;
  const is_keyed_transition = direction === "key";
  let can_show_intro_on_mount = true;
  let can_apply_lazy_transitions = false;
  if (is_keyed_transition) {
    dom.__animate = true;
  }
  let transition_block = block;
  main:
    while (transition_block !== null) {
      if (is_transition_block(transition_block)) {
        if (transition_block.t === EACH_ITEM_BLOCK) {
          transition_block.r = each_item_transition;
          transition_block.a = each_item_animate;
          transition_block = transition_block.p;
        } else if (transition_block.t === AWAIT_BLOCK && transition_block.n) {
          can_show_intro_on_mount = true;
        } else if (transition_block.t === IF_BLOCK) {
          transition_block.r = if_block_transition;
          if (can_show_intro_on_mount) {
            let if_block2 = transition_block;
            while (if_block2.t === IF_BLOCK) {
              if (if_block2.e !== null && !if_block2.v) {
                can_show_intro_on_mount = true;
                break main;
              }
              if_block2 = if_block2.p;
            }
          }
        }
        if (!can_apply_lazy_transitions && can_show_intro_on_mount) {
          can_show_intro_on_mount = transition_block.e !== null;
        }
        if (can_show_intro_on_mount || !global) {
          can_apply_lazy_transitions = true;
        }
      } else if (transition_block.t === ROOT_BLOCK && !can_apply_lazy_transitions) {
        can_show_intro_on_mount = transition_block.e !== null || transition_block.i;
      }
      transition_block = transition_block.p;
    }
  let transition2;
  effect(() => {
    let already_mounted = false;
    if (transition2 !== void 0) {
      already_mounted = true;
      transition2.x();
    }
    const transition_fn = get_transition_fn();
    const init2 = (from) => untrack(() => {
      const props = props_fn === null ? {} : props_fn();
      return is_keyed_transition ? (
        /** @type {import('./types.js').AnimateFn<any>} */
        transition_fn(
          dom,
          { from: (
            /** @type {DOMRect} */
            from
          ), to: dom.getBoundingClientRect() },
          props,
          {}
        )
      ) : (
        /** @type {import('./types.js').TransitionFn<any>} */
        transition_fn(dom, props, {
          direction
        })
      );
    });
    transition2 = create_transition(dom, init2, direction, transition_effect);
    const is_intro = direction === "in";
    const show_intro = can_show_intro_on_mount && (is_intro || direction === "both");
    if (show_intro && !already_mounted) {
      transition2.p = transition2.i();
    }
    const effect2 = managed_pre_effect(() => {
      destroy_signal(effect2);
      dom.inert = false;
      if (show_intro && !already_mounted) {
        transition2.in();
      }
      let transition_block2 = block;
      while (!is_intro && transition_block2 !== null) {
        const parent = transition_block2.p;
        if (is_transition_block(transition_block2)) {
          if (transition_block2.r !== null) {
            transition_block2.r(transition2);
          }
          if (parent === null || !global && (transition_block2.t !== IF_BLOCK || parent.t !== IF_BLOCK || parent.v)) {
            break;
          }
        }
        transition_block2 = parent;
      }
    }, false);
  });
  if (direction === "key") {
    effect(() => {
      return () => {
        transition2.x();
      };
    });
  }
}
function trigger_transitions(transitions, target_direction, from) {
  const outros = [];
  for (const transition2 of transitions) {
    const direction = transition2.r;
    const effect2 = transition2.e;
    if (target_direction === "in") {
      if (direction === "in" || direction === "both") {
        transition2.in();
      } else {
        transition2.c();
      }
      transition2.d.inert = false;
      mark_subtree_inert(effect2, false);
    } else if (target_direction === "key") {
      if (direction === "key") {
        if (!transition2.p) {
          transition2.p = transition2.i(
            /** @type {DOMRect} */
            from
          );
        }
        transition2.in();
      }
    } else {
      if (direction === "out" || direction === "both") {
        if (!transition2.p) {
          transition2.p = transition2.i();
        }
        outros.push(transition2.o);
      }
      transition2.d.inert = true;
      mark_subtree_inert(effect2, true);
    }
  }
  if (outros.length > 0) {
    const e = managed_pre_effect(() => {
      destroy_signal(e);
      const e2 = managed_effect(() => {
        destroy_signal(e2);
        run_all(outros);
      });
    }, false);
  }
}
function if_block_transition(transition2) {
  const block = this;
  if (block.v) {
    const consequent_transitions = block.c ?? (block.c = /* @__PURE__ */ new Set());
    consequent_transitions.add(transition2);
    transition2.f(() => {
      const c = (
        /** @type {Set<import('./types.js').Transition>} */
        consequent_transitions
      );
      c.delete(transition2);
      if (!block.v && c.size === 0) {
        const consequent_effect = block.ce;
        execute_effect(
          /** @type {import('./types.js').EffectSignal} */
          consequent_effect
        );
      }
    });
  } else {
    const alternate_transitions = block.a ?? (block.a = /* @__PURE__ */ new Set());
    alternate_transitions.add(transition2);
    transition2.f(() => {
      const a = (
        /** @type {Set<import('./types.js').Transition>} */
        alternate_transitions
      );
      a.delete(transition2);
      if (block.v && a.size === 0) {
        const alternate_effect = block.ae;
        execute_effect(
          /** @type {import('./types.js').EffectSignal} */
          alternate_effect
        );
      }
    });
  }
}
function each_item_transition(transition2) {
  const block = this;
  const each_block = block.p;
  const is_controlled = (each_block.f & EACH_IS_CONTROLLED) !== 0;
  if (is_controlled) {
    const anchor = empty();
    each_block.f ^= EACH_IS_CONTROLLED;
    append_child(
      /** @type {Element} */
      each_block.a,
      anchor
    );
    each_block.a = anchor;
  }
  if (transition2.r === "key" && (each_block.f & EACH_IS_ANIMATED) === 0) {
    each_block.f |= EACH_IS_ANIMATED;
  }
  const transitions = block.s ?? (block.s = /* @__PURE__ */ new Set());
  transition2.f(() => {
    transitions.delete(transition2);
    if (transition2.r !== "key") {
      for (let other of transitions) {
        const type = other.r;
        if (type === "key" || type === "in") {
          transitions.delete(other);
        }
      }
      if (transitions.size === 0) {
        block.s = null;
        destroy_each_item_block(block, null, true);
      }
    }
  });
  transitions.add(transition2);
}
function each_item_animate(block, transitions) {
  const from_dom = (
    /** @type {Element} */
    get_first_element(block)
  );
  const from = from_dom.getBoundingClientRect();
  for (const transition2 of transitions) {
    const type = transition2.r;
    if (type === "key") {
      transition2.c();
    }
  }
  schedule_raf_task(() => {
    trigger_transitions(transitions, "key", from);
  });
}

// node_modules/svelte/src/internal/client/dom/blocks/await.js
function create_await_block() {
  return {
    // dom
    d: null,
    // effect
    e: null,
    // parent
    p: (
      /** @type {import('../../types.js').Block} */
      current_block
    ),
    // pending
    n: true,
    // transition
    r: null,
    // type
    t: AWAIT_BLOCK
  };
}
function await_block(anchor_node, input, pending_fn, then_fn, catch_fn) {
  const block = create_await_block();
  let current_render = null;
  hydrate_block_anchor(anchor_node);
  let latest_token;
  let resolved_value = UNINITIALIZED;
  let error = UNINITIALIZED;
  let pending = false;
  block.r = /**
   * @param {import('../../types.js').Transition} transition
   * @returns {void}
   */
  (transition2) => {
    const render2 = (
      /** @type {import('../../types.js').Render} */
      current_render
    );
    const transitions = render2.s;
    transitions.add(transition2);
    transition2.f(() => {
      transitions.delete(transition2);
      if (transitions.size === 0) {
        if (current_render !== render2 && render2.e !== null) {
          if (render2.d !== null) {
            remove(render2.d);
            render2.d = null;
          }
          destroy_signal(render2.e);
          render2.e = null;
        }
      }
    });
  };
  const create_render_effect = () => {
    const render2 = {
      d: null,
      e: null,
      s: /* @__PURE__ */ new Set(),
      p: current_render
    };
    const effect2 = render_effect(
      () => {
        if (error === UNINITIALIZED) {
          if (resolved_value === UNINITIALIZED) {
            block.n = true;
            if (pending_fn !== null) {
              pending_fn(anchor_node);
            }
          } else if (then_fn !== null) {
            block.n = false;
            then_fn(anchor_node, resolved_value);
          }
        } else if (catch_fn !== null) {
          block.n = false;
          catch_fn(anchor_node, error);
        }
        render2.d = block.d;
        block.d = null;
      },
      block,
      true,
      true
    );
    render2.e = effect2;
    current_render = render2;
  };
  const render = () => {
    const render2 = current_render;
    if (render2 === null) {
      create_render_effect();
      return;
    }
    const transitions = render2.s;
    if (transitions.size === 0) {
      if (render2.d !== null) {
        remove(render2.d);
        render2.d = null;
      }
      if (render2.e) {
        execute_effect(render2.e);
      } else {
        create_render_effect();
      }
    } else {
      create_render_effect();
      trigger_transitions(transitions, "out");
    }
  };
  const await_effect = render_effect(
    () => {
      const token = {};
      latest_token = token;
      const promise = input();
      if (is_promise(promise)) {
        promise.then(
          /** @param {V} v */
          (v) => {
            if (latest_token === token) {
              flushSync();
              resolved_value = v;
              pending = false;
              render();
            }
          },
          /** @param {unknown} _error */
          (_error) => {
            error = _error;
            pending = false;
            render();
          }
        );
        if (resolved_value !== UNINITIALIZED || error !== UNINITIALIZED) {
          error = UNINITIALIZED;
          resolved_value = UNINITIALIZED;
        }
        if (!pending) {
          pending = true;
          render();
        }
      } else {
        error = UNINITIALIZED;
        resolved_value = promise;
        pending = false;
        render();
      }
    },
    block,
    false
  );
  push_destroy_fn(await_effect, () => {
    let render2 = current_render;
    latest_token = {};
    while (render2 !== null) {
      const dom = render2.d;
      if (dom !== null) {
        remove(dom);
      }
      const effect2 = render2.e;
      if (effect2 !== null) {
        destroy_signal(effect2);
      }
      render2 = render2.p;
    }
  });
  block.e = await_effect;
}

// node_modules/svelte/src/internal/client/dom/blocks/if.js
function create_if_block() {
  return {
    // alternate transitions
    a: null,
    // alternate effect
    ae: null,
    // consequent transitions
    c: null,
    // consequent effect
    ce: null,
    // dom
    d: null,
    // effect
    e: null,
    // parent
    p: (
      /** @type {import('../../types.js').Block} */
      current_block
    ),
    // transition
    r: null,
    // type
    t: IF_BLOCK,
    // value
    v: false
  };
}
function if_block(anchor_node, condition_fn, consequent_fn, alternate_fn) {
  const block = create_if_block();
  hydrate_block_anchor(anchor_node);
  let mismatch = false;
  let consequent_dom = null;
  let alternate_dom = null;
  let has_mounted = false;
  let current_branch_effect = null;
  const if_effect = render_effect(
    () => {
      var _a, _b;
      const result = !!condition_fn();
      if (block.v !== result || !has_mounted) {
        block.v = result;
        if (has_mounted) {
          const consequent_transitions = block.c;
          const alternate_transitions = block.a;
          if (result) {
            if (alternate_transitions === null || alternate_transitions.size === 0) {
              execute_effect(alternate_effect);
            } else {
              trigger_transitions(alternate_transitions, "out");
            }
            if (consequent_transitions === null || consequent_transitions.size === 0) {
              execute_effect(consequent_effect);
            } else {
              trigger_transitions(consequent_transitions, "in");
            }
          } else {
            if (consequent_transitions === null || consequent_transitions.size === 0) {
              execute_effect(consequent_effect);
            } else {
              trigger_transitions(consequent_transitions, "out");
            }
            if (alternate_transitions === null || alternate_transitions.size === 0) {
              execute_effect(alternate_effect);
            } else {
              trigger_transitions(alternate_transitions, "in");
            }
          }
        } else if (hydrating) {
          const comment_text = (
            /** @type {Comment} */
            (_b = (_a = current_hydration_fragment) == null ? void 0 : _a[0]) == null ? void 0 : _b.data
          );
          if (!comment_text || comment_text === "ssr:if:true" && !result || comment_text === "ssr:if:false" && result) {
            remove(current_hydration_fragment);
            set_current_hydration_fragment(null);
            mismatch = true;
          } else {
            current_hydration_fragment.shift();
          }
        }
        has_mounted = true;
      }
    },
    block,
    false
  );
  const consequent_effect = render_effect(
    (_, consequent_effect2) => {
      const result = block.v;
      if (!result && consequent_dom !== null) {
        remove(consequent_dom);
        consequent_dom = null;
      }
      if (result && current_branch_effect !== consequent_effect2) {
        consequent_fn(anchor_node);
        if (mismatch && current_branch_effect === null) {
          set_current_hydration_fragment([]);
        }
        current_branch_effect = consequent_effect2;
        consequent_dom = block.d;
      }
      block.d = null;
    },
    block,
    true
  );
  block.ce = consequent_effect;
  const alternate_effect = render_effect(
    (_, alternate_effect2) => {
      const result = block.v;
      if (result && alternate_dom !== null) {
        remove(alternate_dom);
        alternate_dom = null;
      }
      if (!result && current_branch_effect !== alternate_effect2) {
        if (alternate_fn !== null) {
          alternate_fn(anchor_node);
        }
        if (mismatch && current_branch_effect === null) {
          set_current_hydration_fragment([]);
        }
        current_branch_effect = alternate_effect2;
        alternate_dom = block.d;
      }
      block.d = null;
    },
    block,
    true
  );
  block.ae = alternate_effect;
  push_destroy_fn(if_effect, () => {
    if (consequent_dom !== null) {
      remove(consequent_dom);
    }
    if (alternate_dom !== null) {
      remove(alternate_dom);
    }
    destroy_signal(consequent_effect);
    destroy_signal(alternate_effect);
  });
  block.e = if_effect;
}

// node_modules/svelte/src/internal/client/dom/blocks/key.js
function create_key_block() {
  return {
    // dom
    d: null,
    // effect
    e: null,
    // parent
    p: (
      /** @type {import('../../types.js').Block} */
      current_block
    ),
    // transition
    r: null,
    // type
    t: KEY_BLOCK
  };
}
function key_block(anchor_node, key, render_fn) {
  const block = create_key_block();
  let current_render = null;
  hydrate_block_anchor(anchor_node);
  let key_value = UNINITIALIZED;
  let mounted = false;
  block.r = /**
   * @param {import('../../types.js').Transition} transition
   * @returns {void}
   */
  (transition2) => {
    const render2 = (
      /** @type {import('../../types.js').Render} */
      current_render
    );
    const transitions = render2.s;
    transitions.add(transition2);
    transition2.f(() => {
      transitions.delete(transition2);
      if (transitions.size === 0) {
        if (current_render !== render2 && render2.e !== null) {
          if (render2.d !== null) {
            remove(render2.d);
            render2.d = null;
          }
          destroy_signal(render2.e);
          render2.e = null;
        }
      }
    });
  };
  const create_render_effect = () => {
    const render2 = {
      d: null,
      e: null,
      s: /* @__PURE__ */ new Set(),
      p: current_render
    };
    const effect2 = render_effect(
      () => {
        render_fn(anchor_node);
        render2.d = block.d;
        block.d = null;
      },
      block,
      true,
      true
    );
    render2.e = effect2;
    current_render = render2;
  };
  const render = () => {
    const render2 = current_render;
    if (render2 === null) {
      create_render_effect();
      return;
    }
    const transitions = render2.s;
    if (transitions.size === 0) {
      if (render2.d !== null) {
        remove(render2.d);
        render2.d = null;
      }
      if (render2.e) {
        execute_effect(render2.e);
      } else {
        create_render_effect();
      }
    } else {
      trigger_transitions(transitions, "out");
      create_render_effect();
    }
  };
  const key_effect = render_effect(
    () => {
      const prev_key_value = key_value;
      key_value = key();
      if (mounted && safe_not_equal(prev_key_value, key_value)) {
        render();
      }
    },
    block,
    false
  );
  render();
  mounted = true;
  push_destroy_fn(key_effect, () => {
    let render2 = current_render;
    while (render2 !== null) {
      const dom = render2.d;
      if (dom !== null) {
        remove(dom);
      }
      const effect2 = render2.e;
      if (effect2 !== null) {
        destroy_signal(effect2);
      }
      render2 = render2.p;
    }
  });
  block.e = key_effect;
}

// node_modules/svelte/src/internal/client/reactivity/store.js
function store_get(store, store_name, stores) {
  let entry = stores[store_name];
  const is_new = entry === void 0;
  if (is_new) {
    entry = {
      store: null,
      last_value: null,
      value: mutable_source(UNINITIALIZED),
      unsubscribe: noop
    };
    stores[store_name] = entry;
  }
  if (is_new || entry.store !== store) {
    entry.unsubscribe();
    entry.store = store ?? null;
    entry.unsubscribe = connect_store_to_signal(store, entry.value);
  }
  const value = get(entry.value);
  return value === UNINITIALIZED ? entry.last_value : value;
}
function connect_store_to_signal(store, source2) {
  if (store == null) {
    set(source2, void 0);
    return noop;
  }
  const run2 = (v) => {
    set_ignore_mutation_validation(true);
    set(source2, v);
    set_ignore_mutation_validation(false);
  };
  return subscribe_to_store(store, run2);
}
function store_set(store, value) {
  store.set(value);
  return value;
}
function unsubscribe_on_destroy(stores) {
  on_destroy(() => {
    let store_name;
    for (store_name in stores) {
      const ref = stores[store_name];
      ref.unsubscribe();
    }
  });
}
function mutate_store(store, expression, new_value) {
  store.set(new_value);
  return expression;
}
function is_store(val) {
  return typeof val === "object" && val !== null && typeof /** @type {import('../types.js').Store<V>} */
  val.subscribe === "function";
}
function update_store(store, store_value, d = 1) {
  store.set(store_value + d);
  return store_value;
}
function update_pre_store(store, store_value, d = 1) {
  const value = store_value + d;
  store.set(value);
  return value;
}
function on_destroy(fn) {
  user_effect(() => () => untrack(fn));
}

// node_modules/svelte/src/internal/client/block.js
function create_root_block(intro) {
  return {
    // dom
    d: null,
    // effect
    e: null,
    // intro
    i: intro,
    // parent
    p: null,
    // transition
    r: null,
    // type
    t: ROOT_BLOCK
  };
}
function create_head_block() {
  return {
    // dom
    d: null,
    // effect
    e: null,
    // parent
    p: (
      /** @type {import('./types.js').Block} */
      current_block
    ),
    // transition
    r: null,
    // type
    t: HEAD_BLOCK
  };
}
function create_dynamic_element_block() {
  return {
    // dom
    d: null,
    // effect
    e: null,
    // parent
    p: (
      /** @type {import('./types.js').Block} */
      current_block
    ),
    // transition
    r: null,
    // type
    t: DYNAMIC_ELEMENT_BLOCK
  };
}
function create_dynamic_component_block() {
  return {
    // dom
    d: null,
    // effect
    e: null,
    // parent
    p: (
      /** @type {import('./types.js').Block} */
      current_block
    ),
    // transition
    r: null,
    // type
    t: DYNAMIC_COMPONENT_BLOCK
  };
}
function create_snippet_block() {
  return {
    // dom
    d: null,
    // parent
    p: (
      /** @type {import('./types.js').Block} */
      current_block
    ),
    // effect
    e: null,
    // transition
    r: null,
    // type
    t: SNIPPET_BLOCK
  };
}

// node_modules/svelte/src/internal/client/render.js
var all_registerd_events = /* @__PURE__ */ new Set();
var root_event_handles = /* @__PURE__ */ new Set();
function template(html2, return_fragment) {
  let cached_content;
  return () => {
    if (cached_content === void 0) {
      const content = create_fragment_from_html(html2);
      cached_content = return_fragment ? content : (
        /** @type {Node} */
        child(content)
      );
    }
    return cached_content;
  };
}
function template_with_script(html2, return_fragment) {
  let cached_content;
  return () => {
    if (cached_content === void 0) {
      const content = create_fragment_with_script_from_html(html2);
      cached_content = return_fragment ? content : (
        /** @type {Node} */
        child(content)
      );
    }
    return cached_content;
  };
}
function svg_template(svg, return_fragment) {
  let cached_content;
  return () => {
    if (cached_content === void 0) {
      const content = (
        /** @type {Node} */
        child(create_fragment_from_html(`<svg>${svg}</svg>`))
      );
      cached_content = return_fragment ? content : (
        /** @type {Node} */
        child(content)
      );
    }
    return cached_content;
  };
}
function svg_template_with_script(svg, return_fragment) {
  let cached_content;
  return () => {
    if (cached_content === void 0) {
      const content = (
        /** @type {Node} */
        child(create_fragment_from_html(`<svg>${svg}</svg>`))
      );
      cached_content = return_fragment ? content : (
        /** @type {Node} */
        child(content)
      );
    }
    return cached_content;
  };
}
function svg_replace(node) {
  const first_child = (
    /** @type {Element} */
    node.firstChild
  );
  node.replaceWith(first_child);
  return first_child;
}
function open_template(is_fragment, use_clone_node, anchor, template_element_fn) {
  if (hydrating) {
    if (anchor !== null) {
      hydrate_block_anchor(anchor, false);
    }
    const fragment = current_hydration_fragment;
    if (fragment !== null) {
      return is_fragment ? fragment : (
        /** @type {Element} */
        fragment[0]
      );
    }
  }
  return use_clone_node ? clone_node(
    /** @type {() => Element} */
    template_element_fn(),
    true
  ) : document.importNode(
    /** @type {() => Element} */
    template_element_fn(),
    true
  );
}
function open(anchor, use_clone_node, template_element_fn) {
  return open_template(false, use_clone_node, anchor, template_element_fn);
}
function open_frag(anchor, use_clone_node, template_element_fn) {
  return open_template(true, use_clone_node, anchor, template_element_fn);
}
var space_template = template(" ", false);
var comment_template = template("<!>", true);
function space_frag(anchor) {
  var node = (
    /** @type {any} */
    open(anchor, true, space_template)
  );
  if (hydrating && (node == null ? void 0 : node.nodeType) !== 3) {
    node = empty();
    anchor.before(node);
  }
  return node;
}
function space(anchor) {
  if (hydrating && anchor.nodeType !== 3) {
    const node = empty();
    anchor.before(node);
    return node;
  }
  return anchor;
}
function comment(anchor) {
  return open_frag(anchor, true, comment_template);
}
function close_template(dom, is_fragment, anchor) {
  const block = (
    /** @type {import('./types.js').Block} */
    current_block
  );
  const current = is_fragment ? is_array(dom) ? dom : (
    /** @type {import('./types.js').TemplateNode[]} */
    Array.from(dom.childNodes)
  ) : dom;
  if (!hydrating && anchor !== null) {
    insert(current, null, anchor);
  }
  block.d = current;
}
function close(anchor, dom) {
  close_template(dom, false, anchor);
}
function close_frag(anchor, dom) {
  close_template(dom, true, anchor);
}
function trusted(fn) {
  return function(...args) {
    const event2 = (
      /** @type {Event} */
      args[0]
    );
    if (event2.isTrusted) {
      fn.apply(this, args);
    }
  };
}
function self(fn) {
  return function(...args) {
    const event2 = (
      /** @type {Event} */
      args[0]
    );
    if (event2.target === this) {
      fn.apply(this, args);
    }
  };
}
function stopPropagation(fn) {
  return function(...args) {
    const event2 = (
      /** @type {Event} */
      args[0]
    );
    event2.stopPropagation();
    return fn.apply(this, args);
  };
}
function once(fn) {
  let ran = false;
  return function(...args) {
    if (ran) {
      return;
    }
    ran = true;
    return fn.apply(this, args);
  };
}
function stopImmediatePropagation(fn) {
  return function(...args) {
    const event2 = (
      /** @type {Event} */
      args[0]
    );
    event2.stopImmediatePropagation();
    return fn.apply(this, args);
  };
}
function preventDefault(fn) {
  return function(...args) {
    const event2 = (
      /** @type {Event} */
      args[0]
    );
    event2.preventDefault();
    return fn.apply(this, args);
  };
}
function event(event_name, dom, handler, capture, passive) {
  const options = {
    capture,
    passive
  };
  function target_handler(event2) {
    handle_event_propagation(dom, event2);
    if (!event2.cancelBubble) {
      return handler.call(this, event2);
    }
  }
  dom.addEventListener(event_name, target_handler, options);
  if (dom === document.body || dom === window || dom === document) {
    render_effect(() => {
      return () => {
        dom.removeEventListener(event_name, target_handler, options);
      };
    });
  }
}
function class_name_effect(dom, value) {
  render_effect(() => {
    const string = value();
    class_name(dom, string);
  });
}
function class_name(dom, value) {
  const prev_class_name = dom.__className;
  const next_class_name = to_class(value);
  if (hydrating && dom.className === next_class_name) {
    dom.__className = next_class_name;
  } else if (prev_class_name !== next_class_name || hydrating && dom.className !== next_class_name) {
    if (next_class_name === "") {
      dom.removeAttribute("class");
    } else {
      set_class_name(dom, next_class_name);
    }
    dom.__className = next_class_name;
  }
}
function text_effect(dom, value) {
  render_effect(() => text(dom, value()));
}
function text(dom, value) {
  const prev_node_value = dom.__nodeValue;
  const next_node_value = stringify(value);
  if (hydrating && dom.nodeValue === next_node_value) {
    dom.__nodeValue = next_node_value;
  } else if (prev_node_value !== next_node_value) {
    dom.nodeValue = next_node_value;
    dom.__nodeValue = next_node_value;
  }
}
function auto_focus(dom, value) {
  if (value) {
    const body = document.body;
    dom.autofocus = true;
    render_effect(
      () => {
        if (document.activeElement === body) {
          dom.focus();
        }
      },
      current_block,
      true,
      false
    );
  }
}
function to_class(value) {
  return value == null ? "" : value;
}
function class_toggle(dom, class_name2, value) {
  if (value) {
    dom.classList.add(class_name2);
  } else {
    dom.classList.remove(class_name2);
  }
}
function class_toggle_effect(dom, class_name2, value) {
  render_effect(() => {
    const string = value();
    class_toggle(dom, class_name2, string);
  });
}
function select_option(select, value, mounting) {
  if (select.multiple) {
    return select_options(select, value);
  }
  for (const option of select.options) {
    const option_value = get_option_value(option);
    if (option_value === value) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value !== void 0) {
    select.selectedIndex = -1;
  }
}
function select_options(select, value) {
  for (const option of select.options) {
    option.selected = ~value.indexOf(get_option_value(option));
  }
}
function get_option_value(option) {
  if ("__value" in option) {
    return option.__value;
  } else {
    return option.value;
  }
}
function bind_online(update2) {
  const status_changed = () => {
    update2(navigator.onLine);
  };
  listen_to_events(window, ["online", "offline"], status_changed);
}
function time_ranges_to_array(ranges) {
  const array = [];
  for (let i = 0; i < ranges.length; i += 1) {
    array.push({ start: ranges.start(i), end: ranges.end(i) });
  }
  return array;
}
function bind_current_time(media, get_value, update2) {
  let raf_id;
  let updating = false;
  const callback = () => {
    cancelAnimationFrame(raf_id);
    if (!media.paused) {
      raf_id = requestAnimationFrame(callback);
    }
    updating = true;
    update2(media.currentTime);
  };
  raf_id = requestAnimationFrame(callback);
  media.addEventListener("timeupdate", callback);
  render_effect(() => {
    const value = get_value();
    if (!updating && !isNaN(
      /** @type {any} */
      value
    )) {
      media.currentTime = /** @type {number} */
      value;
    }
    updating = false;
  });
  render_effect(() => () => cancelAnimationFrame(raf_id));
}
function bind_buffered(media, update2) {
  const callback = () => {
    update2(time_ranges_to_array(media.buffered));
  };
  listen_to_events(media, ["loadedmetadata", "progress"], callback);
}
function bind_seekable(media, update2) {
  const callback = () => {
    update2(time_ranges_to_array(media.seekable));
  };
  listen_to_events(media, ["loadedmetadata"], callback);
}
function bind_played(media, update2) {
  const callback = () => {
    update2(time_ranges_to_array(media.played));
  };
  listen_to_events(media, ["timeupdate"], callback);
}
function bind_seeking(media, update2) {
  const callback = () => {
    update2(media.seeking);
  };
  listen_to_events(media, ["seeking", "seeked"], callback);
}
function bind_ended(media, update2) {
  const callback = () => {
    update2(media.ended);
  };
  listen_to_events(media, ["timeupdate", "ended"], callback);
}
function bind_ready_state(media, update2) {
  const callback = () => {
    update2(media.readyState);
  };
  listen_to_events(
    media,
    ["loadedmetadata", "loadeddata", "canplay", "canplaythrough", "playing", "waiting", "emptied"],
    callback
  );
}
function bind_playback_rate(media, get_value, update2) {
  let updating = false;
  const callback = () => {
    if (!updating) {
      update2(media.playbackRate);
    }
    updating = false;
  };
  let render;
  let destroyed = false;
  const effect2 = managed_effect(() => {
    destroy_signal(effect2);
    if (destroyed)
      return;
    if (get_value() == null) {
      callback();
    }
    listen_to_events(media, ["ratechange"], callback, false);
    render = render_effect(() => {
      const value = get_value();
      if (!isNaN(
        /** @type {any} */
        value
      ) && value !== media.playbackRate) {
        updating = true;
        media.playbackRate = /** @type {number} */
        value;
      }
    });
  });
  render_effect(() => () => {
    destroyed = true;
    if (render) {
      destroy_signal(render);
    }
  });
}
function bind_paused(media, get_value, update2) {
  let mounted = hydrating;
  let paused = get_value();
  const callback = () => {
    if (paused !== media.paused) {
      paused = media.paused;
      update2(paused = media.paused);
    }
  };
  if (paused == null) {
    callback();
  }
  if (mounted) {
    listen_to_events(media, ["play", "pause", "canplay"], callback, false);
  }
  render_effect(() => {
    paused = !!get_value();
    if (paused !== media.paused) {
      const toggle = () => {
        mounted = true;
        if (paused) {
          media.pause();
        } else {
          media.play().catch(() => {
            update2(paused = true);
          });
        }
      };
      if (mounted) {
        toggle();
      } else {
        media.addEventListener(
          "canplay",
          () => {
            listen_to_events(media, ["play", "pause", "canplay"], callback, false);
            toggle();
          },
          { once: true }
        );
      }
    }
  });
}
function bind_volume(media, get_value, update2) {
  let updating = false;
  const callback = () => {
    updating = true;
    update2(media.volume);
  };
  if (get_value() == null) {
    callback();
  }
  listen_to_events(media, ["volumechange"], callback, false);
  render_effect(() => {
    const value = get_value();
    if (!updating && !isNaN(
      /** @type {any} */
      value
    )) {
      media.volume = /** @type {number} */
      value;
    }
    updating = false;
  });
}
function bind_muted(media, get_value, update2) {
  let updating = false;
  const callback = () => {
    updating = true;
    update2(media.muted);
  };
  if (get_value() == null) {
    callback();
  }
  listen_to_events(media, ["volumechange"], callback, false);
  render_effect(() => {
    const value = get_value();
    if (!updating) {
      media.muted = !!value;
    }
    updating = false;
  });
}
function listen_to_events(dom, events, handler, call_handler_immediately = true) {
  if (call_handler_immediately) {
    handler();
  }
  for (const name of events) {
    dom.addEventListener(name, handler);
  }
  render_effect(() => {
    return () => {
      for (const name of events) {
        dom.removeEventListener(name, handler);
      }
    };
  });
}
var _listeners, _observer, _options, _getObserver, getObserver_fn;
var _ResizeObserverSingleton = class _ResizeObserverSingleton {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    __privateAdd(this, _getObserver);
    /** */
    __privateAdd(this, _listeners, /* @__PURE__ */ new WeakMap());
    /** @type {ResizeObserver | undefined} */
    __privateAdd(this, _observer, void 0);
    /** @type {ResizeObserverOptions} */
    __privateAdd(this, _options, void 0);
    __privateSet(this, _options, options);
  }
  /**
   * @param {Element} element
   * @param {(entry: ResizeObserverEntry) => any} listener
   */
  observe(element2, listener) {
    const listeners = __privateGet(this, _listeners).get(element2) || /* @__PURE__ */ new Set();
    listeners.add(listener);
    __privateGet(this, _listeners).set(element2, listeners);
    __privateMethod(this, _getObserver, getObserver_fn).call(this).observe(element2, __privateGet(this, _options));
    return () => {
      const listeners2 = __privateGet(this, _listeners).get(element2);
      listeners2.delete(listener);
      if (listeners2.size === 0) {
        __privateGet(this, _listeners).delete(element2);
        __privateGet(this, _observer).unobserve(element2);
      }
    };
  }
};
_listeners = new WeakMap();
_observer = new WeakMap();
_options = new WeakMap();
_getObserver = new WeakSet();
getObserver_fn = function() {
  return __privateGet(this, _observer) ?? __privateSet(this, _observer, new ResizeObserver(
    /** @param {any} entries */
    (entries) => {
      for (const entry of entries) {
        _ResizeObserverSingleton.entries.set(entry.target, entry);
        for (const listener of __privateGet(this, _listeners).get(entry.target) || []) {
          listener(entry);
        }
      }
    }
  ));
};
/** @static */
__publicField(_ResizeObserverSingleton, "entries", /* @__PURE__ */ new WeakMap());
var ResizeObserverSingleton = _ResizeObserverSingleton;
var resize_observer_content_box = new ResizeObserverSingleton({
  box: "content-box"
});
var resize_observer_border_box = new ResizeObserverSingleton({
  box: "border-box"
});
var resize_observer_device_pixel_content_box = new ResizeObserverSingleton({
  box: "device-pixel-content-box"
});
function bind_resize_observer(dom, type, update2) {
  const observer = type === "contentRect" || type === "contentBoxSize" ? resize_observer_content_box : type === "borderBoxSize" ? resize_observer_border_box : resize_observer_device_pixel_content_box;
  const unsub = observer.observe(
    dom,
    /** @param {any} entry */
    (entry) => update2(entry[type])
  );
  render_effect(() => unsub);
}
function bind_element_size(dom, type, update2) {
  const unsub = resize_observer_border_box.observe(dom, () => update2(dom[type]));
  effect(() => {
    untrack(() => update2(dom[type]));
    return unsub;
  });
}
function bind_window_size(type, update2) {
  const callback = () => update2(window[type]);
  listen_to_events(window, ["resize"], callback);
}
function selected(dom) {
  effect(() => {
    let select = dom.parentNode;
    while (select != null) {
      if (select.nodeName === "SELECT") {
        break;
      }
      select = select.parentNode;
    }
    if (select != null && dom.__value === select.__value) {
      dom.selected = true;
    }
  });
}
function bind_value(dom, get_value, update2) {
  dom.addEventListener("input", () => {
    if (DEV && dom.type === "checkbox") {
      throw new Error(
        "Using bind:value together with a checkbox input is not allowed. Use bind:checked instead"
      );
    }
    let value = dom.value;
    if (is_numberlike_input(dom)) {
      value = to_number(value);
    }
    update2(value);
  });
  render_effect(() => {
    if (DEV && dom.type === "checkbox") {
      throw new Error(
        "Using bind:value together with a checkbox input is not allowed. Use bind:checked instead"
      );
    }
    const value = get_value();
    dom.__value = value;
    if (is_numberlike_input(dom) && value === to_number(dom.value)) {
      return;
    }
    if (dom.type === "date" && !value && !dom.value) {
      return;
    }
    dom.value = stringify(value);
  });
}
function is_numberlike_input(dom) {
  const type = dom.type;
  return type === "number" || type === "range";
}
function to_number(value) {
  return value === "" ? null : +value;
}
function bind_select_value(dom, get_value, update2) {
  let mounting = true;
  dom.addEventListener("change", () => {
    let value;
    if (dom.multiple) {
      value = [].map.call(dom.querySelectorAll(":checked"), get_option_value);
    } else {
      const selected_option = dom.querySelector(":checked");
      value = selected_option && get_option_value(selected_option);
    }
    update2(value);
  });
  effect(() => {
    let value = get_value();
    select_option(dom, value, mounting);
    if (mounting && value === void 0) {
      let selected_option = dom.querySelector(":checked");
      if (selected_option !== null) {
        value = get_option_value(selected_option);
        update2(value);
      }
    }
    dom.__value = value;
    mounting = false;
  });
}
function bind_content_editable(property, dom, get_value, update2) {
  dom.addEventListener("input", () => {
    const value = dom[property];
    update2(value);
  });
  render_effect(() => {
    const value = get_value();
    if (dom[property] !== value) {
      if (value === null) {
        const non_null_value = dom[property];
        update2(non_null_value);
      } else {
        dom[property] = value + "";
      }
    }
  });
}
function get_binding_group_value(group, __value, checked) {
  const value = /* @__PURE__ */ new Set();
  for (let i = 0; i < group.length; i += 1) {
    if (group[i].checked) {
      value.add(group[i].__value);
    }
  }
  if (!checked) {
    value.delete(__value);
  }
  return Array.from(value);
}
function bind_group(group, group_index, dom, get_value, update2) {
  const is_checkbox = dom.getAttribute("type") === "checkbox";
  let binding_group = group;
  if (group_index !== null) {
    for (const index of group_index) {
      const group2 = binding_group;
      binding_group = group2[index];
      if (binding_group === void 0) {
        binding_group = group2[index] = [];
      }
    }
  }
  binding_group.push(dom);
  dom.addEventListener("change", () => {
    let value = dom.__value;
    if (is_checkbox) {
      value = get_binding_group_value(binding_group, value, dom.checked);
    }
    update2(value);
  });
  render_effect(() => {
    let value = get_value();
    if (is_checkbox) {
      value = value || [];
      dom.checked = value.includes(dom.__value);
    } else {
      dom.checked = dom.__value === value;
    }
  });
  render_effect(() => {
    return () => {
      const index = binding_group.indexOf(dom);
      if (index !== -1) {
        binding_group.splice(index, 1);
      }
    };
  });
}
function bind_checked(dom, get_value, update2) {
  dom.addEventListener("change", () => {
    const value = dom.checked;
    update2(value);
  });
  if (get_value() == void 0) {
    update2(false);
  }
  render_effect(() => {
    const value = get_value();
    dom.checked = Boolean(value);
  });
}
function bind_window_scroll(type, get_value, update2) {
  const is_scrolling_x = type === "x";
  const target_handler = () => {
    scrolling = true;
    clearTimeout(timeout);
    timeout = setTimeout(clear, 100);
    const value = window[is_scrolling_x ? "scrollX" : "scrollY"];
    update2(value);
  };
  addEventListener("scroll", target_handler, {
    passive: true
  });
  let latest_value = 0;
  let scrolling = false;
  let timeout;
  const clear = () => {
    scrolling = false;
  };
  render_effect(() => {
    latest_value = get_value() || 0;
    if (!scrolling) {
      scrolling = true;
      clearTimeout(timeout);
      if (is_scrolling_x) {
        scrollTo(latest_value, window.scrollY);
      } else {
        scrollTo(window.scrollX, latest_value);
      }
      timeout = setTimeout(clear, 100);
    }
  });
  render_effect(() => {
    return () => {
      removeEventListener("scroll", target_handler);
    };
  });
}
function bind_property(property, event_name, type, dom, get_value, update2) {
  const target_handler = () => {
    const value = dom[property];
    update2(value);
  };
  dom.addEventListener(event_name, target_handler);
  if (type === "set") {
    render_effect(() => {
      const value = get_value();
      dom[property] = value;
    });
  }
  if (type === "get") {
    const value = dom[property];
    update2(value);
  }
  render_effect(() => {
    if (dom === document.body || dom === window || dom === document) {
      return () => {
        dom.removeEventListener(event_name, target_handler);
      };
    }
  });
}
function bind_prop(props, prop2, value) {
  const desc = get_descriptor(props, prop2);
  if (desc && desc.set) {
    props[prop2] = value;
    render_effect(() => () => {
      props[prop2] = null;
    });
  }
}
function bind_this(element_or_component, update2, get_value, get_parts) {
  let old_parts;
  let parts;
  const e = effect(() => {
    old_parts = parts;
    parts = (get_parts == null ? void 0 : get_parts()) || [];
    untrack(() => {
      if (element_or_component !== get_value(...parts)) {
        update2(element_or_component, ...parts);
        if (old_parts && get_value(...old_parts) === element_or_component) {
          update2(null, ...old_parts);
        }
      }
    });
  });
  push_destroy_fn(e, () => {
    effect(() => {
      if (get_value(...parts) === element_or_component) {
        update2(null, ...parts);
      }
    });
  });
}
function delegate(events) {
  for (let i = 0; i < events.length; i++) {
    all_registerd_events.add(events[i]);
  }
  for (const fn of root_event_handles) {
    fn(events);
  }
}
function handle_event_propagation(handler_element, event2) {
  var _a;
  const owner_document = handler_element.ownerDocument;
  const event_name = event2.type;
  const path = ((_a = event2.composedPath) == null ? void 0 : _a.call(event2)) || [];
  let current_target = (
    /** @type {null | Element} */
    path[0] || event2.target
  );
  if (event2.target !== current_target) {
    define_property(event2, "target", {
      configurable: true,
      value: current_target
    });
  }
  let path_idx = 0;
  const handled_at = event2.__root;
  if (handled_at) {
    const at_idx = path.indexOf(handled_at);
    if (at_idx !== -1 && (handler_element === document || handler_element === /** @type {any} */
    window)) {
      event2.__root = handler_element;
      return;
    }
    const handler_idx = path.indexOf(handler_element);
    if (handler_idx === -1) {
      return;
    }
    if (at_idx <= handler_idx) {
      path_idx = at_idx + 1;
    }
  }
  current_target = /** @type {Element} */
  path[path_idx] || event2.target;
  define_property(event2, "currentTarget", {
    configurable: true,
    get() {
      return current_target || owner_document;
    }
  });
  while (current_target !== null) {
    const parent_element = current_target.parentNode || /** @type {any} */
    current_target.host || null;
    const internal_prop_name = "__" + event_name;
    const delegated = current_target[internal_prop_name];
    if (delegated !== void 0 && !/** @type {any} */
    current_target.disabled) {
      if (is_array(delegated)) {
        const [fn, ...data] = delegated;
        fn.apply(current_target, [event2, ...data]);
      } else {
        delegated.call(current_target, event2);
      }
    }
    if (event2.cancelBubble || parent_element === handler_element || current_target === handler_element) {
      break;
    }
    current_target = parent_element;
  }
  event2.__root = handler_element;
  current_target = handler_element;
}
function slot(anchor_node, slot_fn, slot_props, fallback_fn) {
  hydrate_block_anchor(anchor_node);
  if (slot_fn === void 0) {
    if (fallback_fn !== null) {
      fallback_fn(anchor_node);
    }
  } else {
    slot_fn(anchor_node, slot_props);
  }
}
function head(render_fn) {
  const block = create_head_block();
  let hydration_fragment = null;
  let previous_hydration_fragment = null;
  let is_hydrating = hydrating;
  if (is_hydrating) {
    hydration_fragment = get_hydration_fragment(document.head.firstChild);
    previous_hydration_fragment = current_hydration_fragment;
    set_current_hydration_fragment(hydration_fragment);
  }
  try {
    const head_effect = render_effect(
      () => {
        const current = block.d;
        if (current !== null) {
          remove(current);
          block.d = null;
        }
        let anchor = null;
        if (!hydrating) {
          anchor = empty();
          document.head.appendChild(anchor);
        }
        render_fn(anchor);
      },
      block,
      false
    );
    push_destroy_fn(head_effect, () => {
      const current = block.d;
      if (current !== null) {
        remove(current);
      }
    });
    block.e = head_effect;
  } finally {
    if (is_hydrating) {
      set_current_hydration_fragment(previous_hydration_fragment);
    }
  }
}
function swap_block_dom(block, from, to) {
  const dom = block.d;
  if (is_array(dom)) {
    for (let i = 0; i < dom.length; i++) {
      if (dom[i] === from) {
        dom[i] = to;
        break;
      }
    }
  } else if (dom === from) {
    block.d = to;
  }
}
function element(anchor_node, tag_fn, is_svg, render_fn) {
  const block = create_dynamic_element_block();
  hydrate_block_anchor(anchor_node);
  let has_mounted = false;
  let tag;
  let element2 = null;
  const element_effect = render_effect(
    () => {
      tag = tag_fn();
      if (has_mounted) {
        execute_effect(render_effect_signal);
      }
      has_mounted = true;
    },
    block,
    false
  );
  const render_effect_signal = render_effect(
    () => {
      var _a, _b;
      const ns = is_svg || tag === "svg" ? namespace_svg : is_svg === false || ((_a = anchor_node.parentElement) == null ? void 0 : _a.tagName) === "foreignObject" ? null : ((_b = anchor_node.parentElement) == null ? void 0 : _b.namespaceURI) ?? null;
      const next_element = tag ? hydrating ? (
        /** @type {Element} */
        current_hydration_fragment[0]
      ) : ns ? document.createElementNS(ns, tag) : document.createElement(tag) : null;
      const prev_element = element2;
      if (prev_element !== null) {
        block.d = null;
      }
      element2 = next_element;
      if (element2 !== null && render_fn !== void 0) {
        let anchor;
        if (hydrating) {
          anchor = /** @type {Comment} */
          element2.firstChild;
        } else {
          anchor = empty();
          element2.appendChild(anchor);
        }
        render_fn(element2, anchor);
      }
      const has_prev_element = prev_element !== null;
      if (has_prev_element) {
        remove(prev_element);
      }
      if (element2 !== null) {
        insert(element2, null, anchor_node);
        if (has_prev_element) {
          const parent_block = block.p;
          swap_block_dom(parent_block, prev_element, element2);
        }
      }
    },
    block,
    true
  );
  push_destroy_fn(element_effect, () => {
    if (element2 !== null) {
      remove(element2);
      block.d = null;
      element2 = null;
    }
    destroy_signal(render_effect_signal);
  });
  block.e = element_effect;
}
function component(anchor_node, component_fn, render_fn) {
  const block = create_dynamic_component_block();
  let current_render = null;
  hydrate_block_anchor(anchor_node);
  let component2 = null;
  block.r = /**
   * @param {import('./types.js').Transition} transition
   * @returns {void}
   */
  (transition2) => {
    const render2 = (
      /** @type {import('./types.js').Render} */
      current_render
    );
    const transitions = render2.s;
    transitions.add(transition2);
    transition2.f(() => {
      transitions.delete(transition2);
      if (transitions.size === 0) {
        if (current_render !== render2 && render2.e !== null) {
          if (render2.d !== null) {
            remove(render2.d);
            render2.d = null;
          }
          destroy_signal(render2.e);
          render2.e = null;
        }
      }
    });
  };
  const create_render_effect = () => {
    const render2 = {
      d: null,
      e: null,
      s: /* @__PURE__ */ new Set(),
      p: current_render
    };
    const effect2 = render_effect(
      () => {
        const current = block.d;
        if (current !== null) {
          remove(current);
          block.d = null;
        }
        if (component2) {
          render_fn(component2);
        }
        render2.d = block.d;
        block.d = null;
      },
      block,
      true
    );
    render2.e = effect2;
    current_render = render2;
  };
  const render = () => {
    const render2 = current_render;
    if (render2 === null) {
      create_render_effect();
      return;
    }
    const transitions = render2.s;
    if (transitions.size === 0) {
      if (render2.d !== null) {
        remove(render2.d);
        render2.d = null;
      }
      if (render2.e) {
        execute_effect(render2.e);
      } else {
        create_render_effect();
      }
    } else {
      create_render_effect();
      trigger_transitions(transitions, "out");
    }
  };
  const component_effect = render_effect(
    () => {
      const next_component = component_fn();
      if (component2 !== next_component) {
        component2 = next_component;
        render();
      }
    },
    block,
    false
  );
  push_destroy_fn(component_effect, () => {
    let render2 = current_render;
    while (render2 !== null) {
      const dom = render2.d;
      if (dom !== null) {
        remove(dom);
      }
      const effect2 = render2.e;
      if (effect2 !== null) {
        destroy_signal(effect2);
      }
      render2 = render2.p;
    }
  });
  block.e = component_effect;
}
function cssProps(anchor, is_html, props, component2) {
  hydrate_block_anchor(anchor);
  let tag;
  let component_anchor;
  if (hydrating) {
    tag = /** @type {HTMLElement | SVGElement} */
    current_hydration_fragment[0];
    component_anchor = /** @type {Comment} */
    tag.firstChild;
  } else {
    if (is_html) {
      tag = document.createElement("div");
      tag.style.display = "contents";
    } else {
      tag = document.createElementNS(namespace_svg, "g");
    }
    insert(tag, null, anchor);
    component_anchor = empty();
    tag.appendChild(component_anchor);
  }
  component2(component_anchor);
  let current_props = {};
  const effect2 = render_effect(() => {
    const next_props = props();
    for (const key in current_props) {
      if (!(key in next_props)) {
        tag.style.removeProperty(key);
      }
    }
    for (const key in next_props) {
      tag.style.setProperty(key, next_props[key]);
    }
    current_props = next_props;
  });
  push_destroy_fn(effect2, () => {
    remove(tag);
  });
}
function stringify(value) {
  return typeof value === "string" ? value : value == null ? "" : value + "";
}
function html(dom, get_value, svg) {
  let html_dom;
  let value;
  const effect2 = render_effect(() => {
    if (value !== (value = get_value())) {
      if (html_dom) {
        remove(html_dom);
      }
      html_dom = reconcile_html(dom, value, svg);
    }
  });
  push_destroy_fn(effect2, () => {
    if (html_dom) {
      remove(html_dom);
    }
  });
}
function transition(dom, get_transition_fn, props, global = false) {
  bind_transition(dom, get_transition_fn, props, "both", global);
}
function animate(dom, get_transition_fn, props) {
  bind_transition(dom, get_transition_fn, props, "key", false);
}
function in_fn(dom, get_transition_fn, props, global = false) {
  bind_transition(dom, get_transition_fn, props, "in", global);
}
function out(dom, get_transition_fn, props, global = false) {
  bind_transition(dom, get_transition_fn, props, "out", global);
}
function action(dom, action2, value_fn) {
  let payload = void 0;
  let needs_deep_read = false;
  effect(() => {
    if (value_fn) {
      const value = value_fn();
      untrack(() => {
        if (payload === void 0) {
          payload = action2(dom, value) || {};
          needs_deep_read = !!(payload == null ? void 0 : payload.update);
        } else {
          const update2 = payload.update;
          if (typeof update2 === "function") {
            update2(value);
          }
        }
      });
      if (needs_deep_read) {
        deep_read_state(value);
      }
    } else {
      untrack(() => payload = action2(dom));
    }
  });
  effect(() => {
    if (payload !== void 0) {
      const destroy = payload.destroy;
      if (typeof destroy === "function") {
        return () => {
          destroy();
        };
      }
    }
  });
}
function remove_input_attr_defaults(dom) {
  if (hydrating) {
    attr(dom, "value", null);
    attr(dom, "checked", null);
  }
}
function remove_textarea_child(dom) {
  if (hydrating && dom.firstChild !== null) {
    dom.textContent = "";
  }
}
function attr_effect(dom, attribute, value) {
  render_effect(() => {
    const string = value();
    attr(dom, attribute, string);
  });
}
function attr(dom, attribute, value) {
  value = value == null ? null : value + "";
  if (DEV) {
    check_src_in_dev_hydration(dom, attribute, value);
  }
  if (!hydrating || dom.getAttribute(attribute) !== value && // If we reset those, they would result in another network request, which we want to avoid.
  // We assume they are the same between client and server as checking if they are equal is expensive
  // (we can't just compare the strings as they can be different between client and server but result in the
  // same url, so we would need to create hidden anchor elements to compare them)
  attribute !== "src" && attribute !== "href" && attribute !== "srcset") {
    if (value === null) {
      dom.removeAttribute(attribute);
    } else {
      dom.setAttribute(attribute, value);
    }
  }
}
function src_url_equal(element_src, url) {
  if (element_src === url)
    return true;
  return new URL(element_src, document.baseURI).href === new URL(url, document.baseURI).href;
}
function split_srcset(srcset) {
  return srcset.split(",").map((src) => src.trim().split(" ").filter(Boolean));
}
function srcset_url_equal(element2, srcset) {
  const element_urls = split_srcset(element2.srcset);
  const urls = split_srcset(srcset ?? "");
  return urls.length === element_urls.length && urls.every(
    ([url, width], i) => width === element_urls[i][1] && // We need to test both ways because Vite will create an a full URL with
    // `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the
    // relative URLs inside srcset are not automatically resolved to absolute URLs by
    // browsers (in contrast to img.src). This means both SSR and DOM code could
    // contain relative or absolute URLs.
    (src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))
  );
}
function check_src_in_dev_hydration(dom, attribute, value) {
  if (!hydrating)
    return;
  if (attribute !== "src" && attribute !== "href" && attribute !== "srcset")
    return;
  if (attribute === "srcset" && srcset_url_equal(dom, value))
    return;
  if (src_url_equal(dom.getAttribute(attribute) ?? "", value ?? ""))
    return;
  console.error(
    `Detected a ${attribute} attribute value change during hydration. This will not be repaired during hydration, the ${attribute} value that came from the server will be used. Related element:`,
    dom,
    " Differing value:",
    value
  );
}
function xlink_attr_effect(dom, attribute, value) {
  render_effect(() => {
    const string = value();
    xlink_attr(dom, attribute, string);
  });
}
function xlink_attr(dom, attribute, value) {
  dom.setAttributeNS("http://www.w3.org/1999/xlink", attribute, value);
}
function set_custom_element_data_effect(node, prop2, value) {
  render_effect(() => {
    set_custom_element_data(node, prop2, value());
  });
}
function set_custom_element_data(node, prop2, value) {
  if (prop2 in node) {
    node[prop2] = typeof node[prop2] === "boolean" && value === "" ? true : value;
  } else {
    attr(node, prop2, value);
  }
}
function style(dom, key, value, important) {
  const style2 = dom.style;
  const prev_value = style2.getPropertyValue(key);
  if (value == null) {
    if (prev_value !== "") {
      style2.removeProperty(key);
    }
  } else if (prev_value !== value) {
    style2.setProperty(key, value, important ? "important" : "");
  }
}
function style_effect(dom, key, value, important) {
  render_effect(() => {
    const string = value();
    style(dom, key, string, important);
  });
}
var always_set_through_set_attribute = ["width", "height"];
var setters_cache = /* @__PURE__ */ new Map();
function get_setters(element2) {
  const setters = [];
  const descriptors = get_descriptors(element2.__proto__);
  for (const key in descriptors) {
    if (descriptors[key].set && !always_set_through_set_attribute.includes(key)) {
      setters.push(key);
    }
  }
  return setters;
}
function spread_attributes_effect(dom, attrs, lowercase_attributes, css_hash) {
  let current = void 0;
  render_effect(() => {
    current = spread_attributes(dom, current, attrs(), lowercase_attributes, css_hash);
  });
}
function spread_attributes(dom, prev, attrs, lowercase_attributes, css_hash) {
  const next = object_assign({}, ...attrs);
  const has_hash = css_hash.length !== 0;
  for (const key in prev) {
    if (!(key in next)) {
      next[key] = null;
    }
  }
  if (has_hash && !next.class) {
    next.class = "";
  }
  let setters = map_get(setters_cache, dom.nodeName);
  if (!setters)
    map_set(setters_cache, dom.nodeName, setters = get_setters(dom));
  for (const key in next) {
    let value = next[key];
    if (value === (prev == null ? void 0 : prev[key]))
      continue;
    const prefix = key[0] + key[1];
    if (prefix === "$$")
      continue;
    if (prefix === "on") {
      const opts = {};
      let event_name = key.slice(2);
      const delegated = DelegatedEvents.includes(event_name);
      if (event_name.endsWith("capture") && event_name !== "ongotpointercapture" && event_name !== "onlostpointercapture") {
        event_name = event_name.slice(0, -7);
        opts.capture = true;
      }
      if (!delegated && (prev == null ? void 0 : prev[key])) {
        dom.removeEventListener(
          event_name,
          /** @type {any} */
          prev[key],
          opts
        );
      }
      if (value != null) {
        if (!delegated) {
          dom.addEventListener(event_name, value, opts);
        } else {
          dom[`__${event_name}`] = value;
          delegate([event_name]);
        }
      }
    } else if (value == null) {
      dom.removeAttribute(key);
    } else if (key === "style") {
      dom.style.cssText = value + "";
    } else if (key === "autofocus") {
      auto_focus(
        /** @type {HTMLElement} */
        dom,
        Boolean(value)
      );
    } else if (key === "__value" || key === "value") {
      dom.value = dom[key] = dom.__value = value;
    } else {
      let name = key;
      if (lowercase_attributes) {
        name = name.toLowerCase();
        name = AttributeAliases[name] || name;
      }
      if (setters.includes(name)) {
        if (DEV) {
          check_src_in_dev_hydration(dom, name, value);
        }
        if (!hydrating || //  @ts-ignore see attr method for an explanation of src/srcset
        dom[name] !== value && name !== "src" && name !== "href" && name !== "srcset") {
          dom[name] = value;
        }
      } else if (typeof value !== "function") {
        if (has_hash && name === "class") {
          if (value)
            value += " ";
          value += css_hash;
        }
        attr(dom, name, value);
      }
    }
  }
  return next;
}
function spread_dynamic_element_attributes_effect(node, attrs, css_hash) {
  let current = void 0;
  render_effect(() => {
    current = spread_dynamic_element_attributes(node, current, attrs(), css_hash);
  });
}
function spread_dynamic_element_attributes(node, prev, attrs, css_hash) {
  if (node.tagName.includes("-")) {
    const next = object_assign({}, ...attrs);
    for (const key in prev) {
      if (!(key in next)) {
        next[key] = null;
      }
    }
    for (const key in next) {
      set_custom_element_data(node, key, next[key]);
    }
    return next;
  } else {
    return spread_attributes(
      /** @type {Element & ElementCSSInlineStyle} */
      node,
      prev,
      attrs,
      node.namespaceURI !== namespace_svg,
      css_hash
    );
  }
}
var rest_props_handler = {
  get(target, key) {
    if (target.exclude.includes(key))
      return;
    return target.props[key];
  },
  getOwnPropertyDescriptor(target, key) {
    if (target.exclude.includes(key))
      return;
    if (key in target.props) {
      return {
        enumerable: true,
        configurable: true,
        value: target.props[key]
      };
    }
  },
  has(target, key) {
    if (target.exclude.includes(key))
      return false;
    return key in target.props;
  },
  ownKeys(target) {
    return Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));
  }
};
function rest_props(props, rest) {
  return new Proxy({ props, exclude: rest }, rest_props_handler);
}
var spread_props_handler = {
  get(target, key) {
    let i = target.props.length;
    while (i--) {
      let p = target.props[i];
      if (is_function(p))
        p = p();
      if (typeof p === "object" && p !== null && key in p)
        return p[key];
    }
  },
  getOwnPropertyDescriptor(target, key) {
    let i = target.props.length;
    while (i--) {
      let p = target.props[i];
      if (is_function(p))
        p = p();
      if (typeof p === "object" && p !== null && key in p)
        return get_descriptor(p, key);
    }
  },
  has(target, key) {
    for (let p of target.props) {
      if (is_function(p))
        p = p();
      if (key in p)
        return true;
    }
    return false;
  },
  ownKeys(target) {
    const keys = [];
    for (let p of target.props) {
      if (is_function(p))
        p = p();
      for (const key in p) {
        if (!keys.includes(key))
          keys.push(key);
      }
    }
    return keys;
  }
};
function spread_props(...props) {
  return new Proxy({ props }, spread_props_handler);
}
function createRoot() {
  throw new Error(
    "`createRoot` has been removed. Use `mount` or `hydrate` instead. See the updated docs for more info: https://svelte-5-preview.vercel.app/docs/breaking-changes#components-are-no-longer-classes"
  );
}
function mount(component2, options) {
  init_operations();
  const anchor = empty();
  options.target.appendChild(anchor);
  return flush_sync(() => _mount(component2, { ...options, anchor }), false);
}
function hydrate(component2, options) {
  var _a, _b;
  init_operations();
  const container = options.target;
  const first_child = (
    /** @type {ChildNode} */
    container.firstChild
  );
  const hydration_fragment = get_hydration_fragment(first_child, true);
  const previous_hydration_fragment = current_hydration_fragment;
  set_current_hydration_fragment(hydration_fragment);
  let anchor = null;
  if (hydration_fragment === null) {
    anchor = empty();
    container.appendChild(anchor);
  }
  let finished_hydrating = false;
  try {
    return flush_sync(() => {
      const instance = _mount(component2, { ...options, anchor });
      set_current_hydration_fragment(null);
      finished_hydrating = true;
      return instance;
    }, false);
  } catch (error) {
    if (!finished_hydrating && options.recover !== false && hydration_fragment !== null) {
      console.error(
        "ERR_SVELTE_HYDRATION_MISMATCH" + (DEV ? ": Hydration failed because the initial UI does not match what was rendered on the server." : ""),
        error
      );
      remove(hydration_fragment);
      first_child.remove();
      (_b = (_a = hydration_fragment[hydration_fragment.length - 1]) == null ? void 0 : _a.nextSibling) == null ? void 0 : _b.remove();
      set_current_hydration_fragment(null);
      return mount(component2, options);
    } else {
      throw error;
    }
  } finally {
    set_current_hydration_fragment(previous_hydration_fragment);
  }
}
function _mount(Component, options) {
  const registered_events = /* @__PURE__ */ new Set();
  const container = options.target;
  const block = create_root_block(options.intro || false);
  let component2 = void 0;
  const effect2 = render_effect(
    () => {
      if (options.context) {
        push({});
        current_component_context.c = options.context;
      }
      if (!options.props) {
        options.props = /** @type {Props} */
        {};
      }
      if (options.events) {
        options.props.$$events = options.events;
      }
      component2 = // @ts-expect-error the public typings are not what the actual function looks like
      Component(options.anchor, options.props) || {};
      if (options.context) {
        pop();
      }
    },
    block,
    true
  );
  block.e = effect2;
  const bound_event_listener = handle_event_propagation.bind(null, container);
  const bound_document_event_listener = handle_event_propagation.bind(null, document);
  const event_handle = (events) => {
    for (let i = 0; i < events.length; i++) {
      const event_name = events[i];
      if (!registered_events.has(event_name)) {
        registered_events.add(event_name);
        container.addEventListener(
          event_name,
          bound_event_listener,
          PassiveDelegatedEvents.includes(event_name) ? {
            passive: true
          } : void 0
        );
        document.addEventListener(
          event_name,
          bound_document_event_listener,
          PassiveDelegatedEvents.includes(event_name) ? {
            passive: true
          } : void 0
        );
      }
    }
  };
  event_handle(array_from(all_registerd_events));
  root_event_handles.add(event_handle);
  mounted_components.set(component2, () => {
    for (const event_name of registered_events) {
      container.removeEventListener(event_name, bound_event_listener);
    }
    root_event_handles.delete(event_handle);
    const dom = block.d;
    if (dom !== null) {
      remove(dom);
    }
    destroy_signal(
      /** @type {import('./types.js').EffectSignal} */
      block.e
    );
  });
  return component2;
}
var mounted_components = /* @__PURE__ */ new WeakMap();
function unmount(component2) {
  const fn = mounted_components.get(component2);
  if (DEV && !fn) {
    console.warn("Tried to unmount a component that was not mounted.");
  }
  fn == null ? void 0 : fn();
}
function sanitize_slots(props) {
  const sanitized = { ...props.$$slots };
  if (props.children)
    sanitized.default = props.children;
  return sanitized;
}
function snippet_effect(get_snippet, node, ...args) {
  const block = create_snippet_block();
  render_effect(() => {
    const snippet = get_snippet();
    if (snippet) {
      untrack(() => snippet(node, ...args));
    }
    return () => {
      if (block.d !== null) {
        remove(block.d);
      }
    };
  }, block);
}
async function append_styles(target, style_sheet_id, styles) {
  await Promise.resolve();
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style2 = create_element("style");
    style2.id = style_sheet_id;
    style2.textContent = styles;
    append_child(
      /** @type {Document} */
      append_styles_to.head || append_styles_to,
      style2
    );
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && /** @type {ShadowRoot} */
  root.host) {
    return (
      /** @type {ShadowRoot} */
      root
    );
  }
  return (
    /** @type {Document} */
    node.ownerDocument
  );
}
function prop(props, key, flags, initial) {
  var _a;
  var immutable = (flags & PROPS_IS_IMMUTABLE) !== 0;
  var runes = (flags & PROPS_IS_RUNES) !== 0;
  var prop_value = (
    /** @type {V} */
    props[key]
  );
  var setter = (_a = get_descriptor(props, key)) == null ? void 0 : _a.set;
  if (prop_value === void 0 && initial !== void 0) {
    if (setter && runes) {
      throw new Error(
        "ERR_SVELTE_BINDING_FALLBACK" + (DEV ? `: Cannot pass undefined to bind:${key} because the property contains a fallback value. Pass a different value than undefined to ${key}.` : "")
      );
    }
    if ((flags & PROPS_IS_LAZY_INITIAL) !== 0)
      initial = initial();
    prop_value = /** @type {V} */
    initial;
    if (setter)
      setter(prop_value);
  }
  var getter = () => {
    var value = (
      /** @type {V} */
      props[key]
    );
    if (value !== void 0)
      initial = void 0;
    return value === void 0 ? (
      /** @type {V} */
      initial
    ) : value;
  };
  if ((flags & PROPS_IS_UPDATED) === 0) {
    return getter;
  }
  if (setter) {
    return function(value) {
      if (arguments.length === 1) {
        setter(value);
        return value;
      } else {
        return getter();
      }
    };
  }
  var from_child = false;
  var was_from_child = false;
  var inner_current_value = mutable_source(prop_value);
  var current_value = derived(() => {
    var parent_value = getter();
    var child_value = get(inner_current_value);
    if (from_child) {
      from_child = false;
      was_from_child = true;
      return child_value;
    }
    was_from_child = false;
    return inner_current_value.v = parent_value;
  });
  if (!immutable)
    current_value.e = safe_equal;
  return function(value, mutation = false) {
    var current = get(current_value);
    if (is_signals_recorded || DEV && inspect_fn) {
      from_child = was_from_child;
      getter();
      get(inner_current_value);
    }
    if (arguments.length > 0) {
      if (mutation || (immutable ? value !== current : safe_not_equal(value, current))) {
        from_child = true;
        set(inner_current_value, mutation ? current : value);
        get(current_value);
      }
      return value;
    }
    return current;
  };
}
function init() {
  const context = (
    /** @type {import('./types.js').ComponentContext} */
    current_component_context
  );
  const callbacks = context.u;
  if (!callbacks)
    return;
  if (callbacks.b.length) {
    pre_effect(() => {
      observe_all(context);
      callbacks.b.forEach(run);
    });
  }
  user_effect(() => {
    const fns = untrack(() => callbacks.m.map(run));
    return () => {
      for (const fn of fns) {
        if (typeof fn === "function") {
          fn();
        }
      }
    };
  });
  if (callbacks.a.length) {
    user_effect(() => {
      observe_all(context);
      callbacks.a.forEach(run);
    });
  }
}
function observe_all(context) {
  if (context.d) {
    for (const signal of context.d)
      get(signal);
  }
  deep_read_state(context.s);
}
function reactive_import(fn) {
  const s = source(0);
  return function() {
    if (arguments.length === 1) {
      set(s, get(s) + 1);
      return arguments[0];
    } else {
      get(s);
      return fn();
    }
  };
}
function bubble_event($$props, event2) {
  var _a;
  var events = (
    /** @type {Record<string, Function[] | Function>} */
    (_a = $$props.$$events) == null ? void 0 : _a[event2.type]
  );
  var callbacks = is_array(events) ? events.slice() : events == null ? [] : [events];
  for (var fn of callbacks) {
    fn.call(this, event2);
  }
}
function add_legacy_event_listener($$props, event_name, event_callback) {
  var _a;
  $$props.$$events || ($$props.$$events = {});
  (_a = $$props.$$events)[event_name] || (_a[event_name] = []);
  $$props.$$events[event_name].push(event_callback);
}
function update_legacy_props($$new_props) {
  for (const key in $$new_props) {
    if (key in this) {
      this[key] = $$new_props[key];
    }
  }
}

// node_modules/svelte/src/internal/client/custom-element.js
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    /**
     * @param {*} $$componentCtor
     * @param {*} $$slots
     * @param {*} use_shadow_dom
     */
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** @type {any} The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** @type {Record<string, any>} Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, EventListenerOrEventListenerObject[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<EventListenerOrEventListenerObject, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      /** @type {any} The managed render effect for reflecting attributes */
      __publicField(this, "$$me");
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    /**
     * @param {string} type
     * @param {EventListenerOrEventListenerObject} listener
     * @param {boolean | AddEventListenerOptions} [options]
     */
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    /**
     * @param {string} type
     * @param {EventListenerOrEventListenerObject} listener
     * @param {boolean | AddEventListenerOptions} [options]
     */
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot = function(name) {
          return (anchor) => {
            const node = open(anchor, true, () => {
              const slot2 = document.createElement("slot");
              if (name !== "default") {
                slot2.name = name;
              }
              return slot2;
            });
            close(
              anchor,
              /** @type {Element} */
              node
            );
          };
        };
        await Promise.resolve();
        if (!this.$$cn || this.$$c) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            if (name === "default") {
              this.$$d.children = create_slot(name);
            } else {
              $$slots[name] = create_slot(name);
            }
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        for (const key in this.$$p_d) {
          if (!(key in this.$$d) && this[key] !== void 0) {
            this.$$d[key] = this[key];
            delete this[key];
          }
        }
        this.$$c = createClassComponent({
          component: this.$$ctor,
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots
          }
        });
        this.$$me = render_effect(() => {
          var _a;
          this.$$r = true;
          for (const key of Object.keys(this.$$c)) {
            if (!((_a = this.$$p_d[key]) == null ? void 0 : _a.reflect))
              continue;
            this.$$d[key] = this.$$c[key];
            const attribute_value = get_custom_element_value(
              key,
              this.$$d[key],
              this.$$p_d,
              "toAttribute"
            );
            if (attribute_value == null) {
              this.removeAttribute(this.$$p_d[key].attribute || key);
            } else {
              this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
            }
          }
          this.$$r = false;
        });
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    /**
     * @param {string} attr
     * @param {string} _oldValue
     * @param {string} newValue
     */
    attributeChangedCallback(attr2, _oldValue, newValue) {
      var _a;
      if (this.$$r)
        return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      (_a = this.$$c) == null ? void 0 : _a.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn) {
          this.$$c.$destroy();
          destroy_signal(this.$$me);
          this.$$c = void 0;
        }
      });
    }
    /**
     * @param {string} attribute_name
     */
    $$g_p(attribute_name) {
      return Object.keys(this.$$p_d).find(
        (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop2, value, props_definition, transform) {
  var _a;
  const type = (_a = props_definition[prop2]) == null ? void 0 : _a.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop2]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach((node) => {
    result[
      /** @type {Element} node */
      node.slot || "default"
    ] = true;
  });
  return result;
}
function create_custom_element(Component, props_definition, slots, exports, use_shadow_dom, extend) {
  let Class = class extends SvelteElement {
    constructor() {
      super(Component, slots, use_shadow_dom);
      this.$$p_d = props_definition;
    }
    static get observedAttributes() {
      return Object.keys(props_definition).map(
        (key) => (props_definition[key].attribute || key).toLowerCase()
      );
    }
  };
  Object.keys(props_definition).forEach((prop2) => {
    define_property(Class.prototype, prop2, {
      get() {
        return this.$$c && prop2 in this.$$c ? this.$$c[prop2] : this.$$d[prop2];
      },
      set(value) {
        var _a;
        value = get_custom_element_value(prop2, value, props_definition);
        this.$$d[prop2] = value;
        (_a = this.$$c) == null ? void 0 : _a.$set({ [prop2]: value });
      }
    });
  });
  exports.forEach((property) => {
    define_property(Class.prototype, property, {
      get() {
        var _a;
        return (_a = this.$$c) == null ? void 0 : _a[property];
      }
    });
  });
  if (extend) {
    Class = extend(Class);
  }
  Component.element = /** @type {any} */
  Class;
  return Class;
}

// node_modules/svelte/src/legacy/legacy-client.js
function createClassComponent(options) {
  return new Svelte4Component(options);
}
function asClassComponent(component2) {
  return class extends Svelte4Component {
    /** @param {any} options */
    constructor(options) {
      super({
        component: component2,
        ...options
      });
    }
  };
}
var _events, _instance;
var Svelte4Component = class {
  /**
   * @param {import('../main/public.js').ComponentConstructorOptions & {
   *  component: any;
   * 	immutable?: boolean;
   * 	hydrate?: boolean;
   * 	recover?: false;
   * }} options
   */
  constructor(options) {
    /** @type {any} */
    __privateAdd(this, _events, {});
    /** @type {Record<string, any>} */
    __privateAdd(this, _instance, void 0);
    const props = proxy({ ...options.props || {}, $$events: __privateGet(this, _events) }, false);
    __privateSet(this, _instance, (options.hydrate ? hydrate : mount)(options.component, {
      target: options.target,
      props,
      context: options.context,
      intro: options.intro,
      recover: options.recover
    }));
    for (const key of Object.keys(__privateGet(this, _instance))) {
      define_property(this, key, {
        get() {
          return __privateGet(this, _instance)[key];
        },
        /** @param {any} value */
        set(value) {
          __privateGet(this, _instance)[key] = value;
        },
        enumerable: true
      });
    }
    __privateGet(this, _instance).$set = /** @param {Record<string, any>} next */
    (next) => {
      Object.assign(props, next);
    };
    __privateGet(this, _instance).$destroy = () => {
      unmount(__privateGet(this, _instance));
    };
  }
  /** @param {Record<string, any>} props */
  $set(props) {
    __privateGet(this, _instance).$set(props);
  }
  /**
   * @param {string} event
   * @param {(...args: any[]) => any} callback
   * @returns {any}
   */
  $on(event2, callback) {
    __privateGet(this, _events)[event2] = __privateGet(this, _events)[event2] || [];
    const cb = (...args) => callback.call(this, ...args);
    __privateGet(this, _events)[event2].push(cb);
    return () => {
      __privateGet(this, _events)[event2] = __privateGet(this, _events)[event2].filter(
        /** @param {any} fn */
        (fn) => fn !== cb
      );
    };
  }
  $destroy() {
    __privateGet(this, _instance).$destroy();
  }
};
_events = new WeakMap();
_instance = new WeakMap();

export {
  $window,
  $document,
  child,
  child_frag,
  sibling,
  create_each_block,
  create_each_item_block,
  each_keyed,
  each_indexed,
  get_first_element,
  destroy_each_item_block,
  await_block,
  if_block,
  key_block,
  store_get,
  store_set,
  unsubscribe_on_destroy,
  mutate_store,
  is_store,
  update_store,
  update_pre_store,
  template,
  template_with_script,
  svg_template,
  svg_template_with_script,
  svg_replace,
  open,
  open_frag,
  space_frag,
  space,
  comment,
  close,
  close_frag,
  trusted,
  self,
  stopPropagation,
  once,
  stopImmediatePropagation,
  preventDefault,
  event,
  class_name_effect,
  class_name,
  text_effect,
  text,
  auto_focus,
  to_class,
  class_toggle,
  class_toggle_effect,
  select_option,
  bind_online,
  bind_current_time,
  bind_buffered,
  bind_seekable,
  bind_played,
  bind_seeking,
  bind_ended,
  bind_ready_state,
  bind_playback_rate,
  bind_paused,
  bind_volume,
  bind_muted,
  bind_resize_observer,
  bind_element_size,
  bind_window_size,
  selected,
  bind_value,
  bind_select_value,
  bind_content_editable,
  bind_group,
  bind_checked,
  bind_window_scroll,
  bind_property,
  bind_prop,
  bind_this,
  delegate,
  slot,
  head,
  element,
  component,
  cssProps,
  stringify,
  html,
  transition,
  animate,
  in_fn,
  out,
  action,
  remove_input_attr_defaults,
  remove_textarea_child,
  attr_effect,
  attr,
  srcset_url_equal,
  xlink_attr_effect,
  xlink_attr,
  set_custom_element_data_effect,
  set_custom_element_data,
  style,
  style_effect,
  spread_attributes_effect,
  spread_attributes,
  spread_dynamic_element_attributes_effect,
  spread_dynamic_element_attributes,
  rest_props,
  spread_props,
  createRoot,
  mount,
  hydrate,
  unmount,
  sanitize_slots,
  snippet_effect,
  append_styles,
  prop,
  init,
  reactive_import,
  bubble_event,
  add_legacy_event_listener,
  update_legacy_props,
  createClassComponent,
  asClassComponent,
  create_custom_element
};
//# sourceMappingURL=chunk-KD4OFIAX.js.map
