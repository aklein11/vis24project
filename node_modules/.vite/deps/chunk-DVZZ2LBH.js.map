{
  "version": 3,
  "sources": ["../../svelte/src/internal/client/utils.js", "../../svelte/src/internal/client/reactivity/equality.js", "../../svelte/src/internal/client/constants.js", "../../svelte/src/internal/client/dev/ownership.js", "../../svelte/src/internal/client/reactivity/sources.js", "../../svelte/src/internal/client/proxy.js", "../../svelte/src/internal/client/dom/task.js", "../../svelte/src/internal/client/runtime.js", "../../svelte/src/internal/client/reactivity/computations.js", "../../svelte/src/constants.js", "../../svelte/src/internal/client/validate.js"],
  "sourcesContent": ["// Store the references to globals in case someone tries to monkey patch these, causing the below\n// to de-opt (this occurs often when using popular extensions).\nexport var is_array = Array.isArray;\nexport var array_from = Array.from;\nexport var object_keys = Object.keys;\nexport var object_assign = Object.assign;\nexport var is_frozen = Object.isFrozen;\nexport var object_freeze = Object.freeze;\nexport var define_property = Object.defineProperty;\nexport var get_descriptor = Object.getOwnPropertyDescriptor;\nexport var get_descriptors = Object.getOwnPropertyDescriptors;\nexport var object_prototype = Object.prototype;\nexport var array_prototype = Array.prototype;\nexport var get_prototype_of = Object.getPrototypeOf;\n\n/**\n * @param {any} thing\n * @returns {thing is Function}\n */\nexport function is_function(thing) {\n\treturn typeof thing === 'function';\n}\n", "/**\n * @param {unknown} a\n * @param {unknown} b\n * @returns {boolean}\n */\nexport function default_equals(a, b) {\n\treturn a === b;\n}\n\n/**\n * @param {unknown} a\n * @param {unknown} b\n * @returns {boolean}\n */\nexport function safe_not_equal(a, b) {\n\t// eslint-disable-next-line eqeqeq\n\treturn a != a\n\t\t? // eslint-disable-next-line eqeqeq\n\t\t\tb == b\n\t\t: a !== b || (a !== null && typeof a === 'object') || typeof a === 'function';\n}\n\n/**\n * @param {unknown} a\n * @param {unknown} b\n * @returns {boolean}\n */\nexport function safe_equal(a, b) {\n\treturn !safe_not_equal(a, b);\n}\n", "export const SOURCE = 1;\nexport const DERIVED = 1 << 1;\nexport const EFFECT = 1 << 2;\nexport const PRE_EFFECT = 1 << 3;\nexport const RENDER_EFFECT = 1 << 4;\nexport const MANAGED = 1 << 6;\nexport const UNOWNED = 1 << 7;\nexport const CLEAN = 1 << 8;\nexport const DIRTY = 1 << 9;\nexport const MAYBE_DIRTY = 1 << 10;\nexport const INERT = 1 << 11;\nexport const DESTROYED = 1 << 12;\n\nexport const ROOT_BLOCK = 0;\nexport const IF_BLOCK = 1;\nexport const EACH_BLOCK = 2;\nexport const EACH_ITEM_BLOCK = 3;\nexport const AWAIT_BLOCK = 4;\nexport const KEY_BLOCK = 5;\nexport const HEAD_BLOCK = 6;\nexport const DYNAMIC_COMPONENT_BLOCK = 7;\nexport const DYNAMIC_ELEMENT_BLOCK = 8;\nexport const SNIPPET_BLOCK = 9;\n\nexport const UNINITIALIZED = Symbol();\nexport const STATE_SYMBOL = Symbol('$state');\n", "/** @typedef {{ file: string, line: number, column: number }} Location */\n\nimport { STATE_SYMBOL } from '../constants.js';\nimport { untrack } from '../runtime.js';\n\n/** @type {Record<string, Array<{ start: Location, end: Location, component: Function }>>} */\nconst boundaries = {};\n\nconst chrome_pattern = /at (?:.+ \\()?(.+):(\\d+):(\\d+)\\)?$/;\nconst firefox_pattern = /@(.+):(\\d+):(\\d+)$/;\n\nexport function get_stack() {\n\tconst stack = new Error().stack;\n\tif (!stack) return null;\n\n\tconst entries = [];\n\n\tfor (const line of stack.split('\\n')) {\n\t\tlet match = chrome_pattern.exec(line) ?? firefox_pattern.exec(line);\n\n\t\tif (match) {\n\t\t\tentries.push({\n\t\t\t\tfile: match[1],\n\t\t\t\tline: +match[2],\n\t\t\t\tcolumn: +match[3]\n\t\t\t});\n\t\t}\n\t}\n\n\treturn entries;\n}\n\n/**\n * Determines which `.svelte` component is responsible for a given state change\n * @returns {Function | null}\n */\nfunction get_component() {\n\t// first 4 lines are svelte internals; adjust this number if we change the internal call stack\n\tconst stack = get_stack()?.slice(4);\n\tif (!stack) return null;\n\n\tfor (let i = 0; i < stack.length; i++) {\n\t\tconst entry = stack[i];\n\t\tconst modules = boundaries[entry.file];\n\t\tif (!modules) {\n\t\t\t// If the first entry is not a component, that means the modification very likely happened\n\t\t\t// within a .svelte.js file, possibly triggered by a component. Since these files are not part\n\t\t\t// of the bondaries/component context heuristic, we need to bail in this case, else we would\n\t\t\t// have false positives when the .svelte.ts file provides a state creator function, encapsulating\n\t\t\t// the state and its mutations, and is being called from a component other than the one who\n\t\t\t// called the state creator function.\n\t\t\tif (i === 0) return null;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (const module of modules) {\n\t\t\tif (module.start.line < entry.line && module.end.line > entry.line) {\n\t\t\t\treturn module.component;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn null;\n}\n\n/**\n * Together with `mark_module_end`, this function establishes the boundaries of a `.svelte` file,\n * such that subsequent calls to `get_component` can tell us which component is responsible\n * for a given state change\n * @param {Function} component\n */\nexport function mark_module_start(component) {\n\tconst start = get_stack()?.[2];\n\n\tif (start) {\n\t\t(boundaries[start.file] ??= []).push({\n\t\t\tstart,\n\t\t\t// @ts-expect-error\n\t\t\tend: null,\n\t\t\tcomponent\n\t\t});\n\t}\n}\n\nexport function mark_module_end() {\n\tconst end = get_stack()?.[2];\n\n\tif (end) {\n\t\tconst boundaries_file = boundaries[end.file];\n\t\tboundaries_file[boundaries_file.length - 1].end = end;\n\t}\n}\n\n/**\n *\n * @param {any} object\n * @param {any} owner\n */\nexport function add_owner(object, owner) {\n\tuntrack(() => {\n\t\tadd_owner_to_object(object, owner);\n\t});\n}\n\n/**\n * @param {any} object\n * @param {Function} owner\n */\nfunction add_owner_to_object(object, owner) {\n\tif (object?.[STATE_SYMBOL]?.o && !object[STATE_SYMBOL].o.has(owner)) {\n\t\tobject[STATE_SYMBOL].o.add(owner);\n\n\t\tfor (const key in object) {\n\t\t\tadd_owner_to_object(object[key], owner);\n\t\t}\n\t}\n}\n\n/**\n * @param {any} object\n */\nexport function strip_owner(object) {\n\tuntrack(() => {\n\t\tstrip_owner_from_object(object);\n\t});\n}\n\n/**\n * @param {any} object\n */\nfunction strip_owner_from_object(object) {\n\tif (object?.[STATE_SYMBOL]?.o) {\n\t\tobject[STATE_SYMBOL].o = null;\n\n\t\tfor (const key in object) {\n\t\t\tstrip_owner(object[key]);\n\t\t}\n\t}\n}\n\n/**\n * @param {Set<Function>} owners\n */\nexport function check_ownership(owners) {\n\tconst component = get_component();\n\n\tif (component && !owners.has(component)) {\n\t\tlet original = [...owners][0];\n\n\t\tlet message =\n\t\t\t// @ts-expect-error\n\t\t\toriginal.filename !== component.filename\n\t\t\t\t? // @ts-expect-error\n\t\t\t\t\t`${component.filename} mutated a value owned by ${original.filename}. This is strongly discouraged`\n\t\t\t\t: 'Mutating a value outside the component that created it is strongly discouraged';\n\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.warn(\n\t\t\t`${message}. Consider passing values to child components with \\`bind:\\`, or use a callback instead.`\n\t\t);\n\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.trace();\n\t}\n}\n", "import { DEV } from 'esm-env';\nimport { current_component_context } from '../runtime.js';\nimport { default_equals, safe_equal } from './equality.js';\nimport { CLEAN, SOURCE } from '../constants.js';\n\n/**\n * @template V\n * @param {V} initial_value\n * @returns {import('../types.js').SourceSignal<V>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function source(initial_value) {\n\treturn create_source_signal(SOURCE | CLEAN, initial_value);\n}\n\n/**\n * @template V\n * @param {V} initial_value\n * @returns {import('../types.js').SourceSignal<V>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function mutable_source(initial_value) {\n\tconst s = source(initial_value);\n\ts.e = safe_equal;\n\n\t// bind the signal to the component context, in case we need to\n\t// track updates to trigger beforeUpdate/afterUpdate callbacks\n\tif (current_component_context) {\n\t\t(current_component_context.d ??= []).push(s);\n\t}\n\n\treturn s;\n}\n\n/**\n * @template V\n * @param {import('../types.js').SignalFlags} flags\n * @param {V} value\n * @returns {import('../types.js').SourceSignal<V> | import('../types.js').SourceSignal<V> & import('../types.js').SourceSignalDebug}\n */\nfunction create_source_signal(flags, value) {\n\tif (DEV) {\n\t\treturn {\n\t\t\t// consumers\n\t\t\tc: null,\n\t\t\t// equals\n\t\t\te: default_equals,\n\t\t\t// flags\n\t\t\tf: flags,\n\t\t\t// value\n\t\t\tv: value,\n\t\t\t// write version\n\t\t\tw: 0,\n\t\t\t// this is for DEV only\n\t\t\tinspect: new Set()\n\t\t};\n\t}\n\treturn {\n\t\t// consumers\n\t\tc: null,\n\t\t// equals\n\t\te: default_equals,\n\t\t// flags\n\t\tf: flags,\n\t\t// value\n\t\tv: value,\n\t\t// write version\n\t\tw: 0\n\t};\n}\n", "import { DEV } from 'esm-env';\nimport {\n\tget,\n\tset,\n\tupdating_derived,\n\tbatch_inspect,\n\tcurrent_component_context,\n\tuntrack,\n\tset_signal_value\n} from './runtime.js';\nimport { effect_active } from './reactivity/computations.js';\nimport {\n\tarray_prototype,\n\tdefine_property,\n\tget_descriptor,\n\tget_descriptors,\n\tget_prototype_of,\n\tis_array,\n\tis_frozen,\n\tobject_prototype\n} from './utils.js';\nimport { add_owner, check_ownership, strip_owner } from './dev/ownership.js';\nimport { mutable_source, source } from './reactivity/sources.js';\nimport { STATE_SYMBOL, UNINITIALIZED } from './constants.js';\n\n/**\n * @template T\n * @param {T} value\n * @param {boolean} [immutable]\n * @param {Set<Function> | null} [owners]\n * @returns {import('./types.js').ProxyStateObject<T> | T}\n */\nexport function proxy(value, immutable = true, owners) {\n\tif (typeof value === 'object' && value != null && !is_frozen(value)) {\n\t\t// If we have an existing proxy, return it...\n\t\tif (STATE_SYMBOL in value) {\n\t\t\tconst metadata = /** @type {import('./types.js').ProxyMetadata<T>} */ (value[STATE_SYMBOL]);\n\t\t\t// ...unless the proxy belonged to a different object, because\n\t\t\t// someone copied the state symbol using `Reflect.ownKeys(...)`\n\t\t\tif (metadata.t === value || metadata.p === value) {\n\t\t\t\tif (DEV) {\n\t\t\t\t\t// update ownership\n\t\t\t\t\tif (owners) {\n\t\t\t\t\t\tfor (const owner of owners) {\n\t\t\t\t\t\t\tadd_owner(value, owner);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstrip_owner(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn metadata.p;\n\t\t\t}\n\t\t}\n\n\t\tconst prototype = get_prototype_of(value);\n\n\t\t// TODO handle Map and Set as well\n\t\tif (prototype === object_prototype || prototype === array_prototype) {\n\t\t\tconst proxy = new Proxy(value, state_proxy_handler);\n\n\t\t\tdefine_property(value, STATE_SYMBOL, {\n\t\t\t\tvalue: /** @type {import('./types.js').ProxyMetadata} */ ({\n\t\t\t\t\ts: new Map(),\n\t\t\t\t\tv: source(0),\n\t\t\t\t\ta: is_array(value),\n\t\t\t\t\ti: immutable,\n\t\t\t\t\tp: proxy,\n\t\t\t\t\tt: value\n\t\t\t\t}),\n\t\t\t\twritable: true,\n\t\t\t\tenumerable: false\n\t\t\t});\n\n\t\t\tif (DEV) {\n\t\t\t\t// set ownership — either of the parent proxy's owners (if provided) or,\n\t\t\t\t// when calling `$.proxy(...)`, to the current component if such there be\n\t\t\t\t// @ts-expect-error\n\t\t\t\tvalue[STATE_SYMBOL].o =\n\t\t\t\t\towners === undefined\n\t\t\t\t\t\t? current_component_context\n\t\t\t\t\t\t\t? // @ts-expect-error\n\t\t\t\t\t\t\t\tnew Set([current_component_context.function])\n\t\t\t\t\t\t\t: null\n\t\t\t\t\t\t: owners && new Set(owners);\n\t\t\t}\n\n\t\t\treturn proxy;\n\t\t}\n\t}\n\n\treturn value;\n}\n\n/**\n * @template {import('./types.js').ProxyStateObject} T\n * @param {T} value\n * @param {Map<T, Record<string | symbol, any>>} already_unwrapped\n * @returns {Record<string | symbol, any>}\n */\nfunction unwrap(value, already_unwrapped) {\n\tif (typeof value === 'object' && value != null && STATE_SYMBOL in value) {\n\t\tconst unwrapped = already_unwrapped.get(value);\n\t\tif (unwrapped !== undefined) {\n\t\t\treturn unwrapped;\n\t\t}\n\n\t\tif (is_array(value)) {\n\t\t\t/** @type {Record<string | symbol, any>} */\n\t\t\tconst array = [];\n\t\t\talready_unwrapped.set(value, array);\n\t\t\tfor (const element of value) {\n\t\t\t\tarray.push(unwrap(element, already_unwrapped));\n\t\t\t}\n\t\t\treturn array;\n\t\t} else {\n\t\t\t/** @type {Record<string | symbol, any>} */\n\t\t\tconst obj = {};\n\t\t\tconst keys = Reflect.ownKeys(value);\n\t\t\tconst descriptors = get_descriptors(value);\n\t\t\talready_unwrapped.set(value, obj);\n\n\t\t\tfor (const key of keys) {\n\t\t\t\tif (key === STATE_SYMBOL) continue;\n\t\t\t\tif (descriptors[key].get) {\n\t\t\t\t\tdefine_property(obj, key, descriptors[key]);\n\t\t\t\t} else {\n\t\t\t\t\t/** @type {T} */\n\t\t\t\t\tconst property = value[key];\n\t\t\t\t\tobj[key] = unwrap(property, already_unwrapped);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn obj;\n\t\t}\n\t}\n\n\treturn value;\n}\n\n/**\n * @template T\n * @param {T} value\n * @returns {T}\n */\nexport function unstate(value) {\n\treturn /** @type {T} */ (\n\t\tunwrap(/** @type {import('./types.js').ProxyStateObject} */ (value), new Map())\n\t);\n}\n\n/**\n * @param {import('./types.js').Signal<number>} signal\n * @param {1 | -1} [d]\n */\nfunction update_version(signal, d = 1) {\n\tconst value = untrack(() => get(signal));\n\tset_signal_value(signal, value + d);\n}\n\n/** @type {ProxyHandler<import('./types.js').ProxyStateObject<any>>} */\nconst state_proxy_handler = {\n\tdefineProperty(target, prop, descriptor) {\n\t\tif (descriptor.value) {\n\t\t\t/** @type {import('./types.js').ProxyMetadata} */\n\t\t\tconst metadata = target[STATE_SYMBOL];\n\n\t\t\tconst s = metadata.s.get(prop);\n\t\t\tif (s !== undefined) set(s, proxy(descriptor.value, metadata.i, metadata.o));\n\t\t}\n\n\t\treturn Reflect.defineProperty(target, prop, descriptor);\n\t},\n\n\tdeleteProperty(target, prop) {\n\t\t/** @type {import('./types.js').ProxyMetadata} */\n\t\tconst metadata = target[STATE_SYMBOL];\n\t\tconst s = metadata.s.get(prop);\n\t\tconst is_array = metadata.a;\n\t\tconst boolean = delete target[prop];\n\n\t\t// If we have mutated an array directly, and the deletion\n\t\t// was successful we will also need to update the length\n\t\t// before updating the field or the version. This is to\n\t\t// ensure any effects observing length can execute before\n\t\t// effects that listen to the fields – otherwise they will\n\t\t// operate an an index that no longer exists.\n\t\tif (is_array && boolean) {\n\t\t\tconst ls = metadata.s.get('length');\n\t\t\tconst length = target.length - 1;\n\t\t\tif (ls !== undefined && ls.v !== length) {\n\t\t\t\tset(ls, length);\n\t\t\t}\n\t\t}\n\t\tif (s !== undefined) set(s, UNINITIALIZED);\n\n\t\tif (boolean) {\n\t\t\tupdate_version(metadata.v);\n\t\t}\n\n\t\treturn boolean;\n\t},\n\n\tget(target, prop, receiver) {\n\t\tif (prop === STATE_SYMBOL) {\n\t\t\treturn Reflect.get(target, STATE_SYMBOL);\n\t\t}\n\n\t\t/** @type {import('./types.js').ProxyMetadata} */\n\t\tconst metadata = target[STATE_SYMBOL];\n\t\tlet s = metadata.s.get(prop);\n\n\t\t// if we're reading a property in a reactive context, create a source,\n\t\t// but only if it's an own property and not a prototype property\n\t\tif (\n\t\t\ts === undefined &&\n\t\t\t(effect_active() || updating_derived) &&\n\t\t\t(!(prop in target) || get_descriptor(target, prop)?.writable)\n\t\t) {\n\t\t\ts = (metadata.i ? source : mutable_source)(proxy(target[prop], metadata.i, metadata.o));\n\t\t\tmetadata.s.set(prop, s);\n\t\t}\n\n\t\tif (s !== undefined) {\n\t\t\tconst value = get(s);\n\t\t\treturn value === UNINITIALIZED ? undefined : value;\n\t\t}\n\n\t\tif (DEV) {\n\t\t\tif (typeof target[prop] === 'function' && prop !== Symbol.iterator) {\n\t\t\t\treturn batch_inspect(target, prop, receiver);\n\t\t\t}\n\t\t}\n\t\treturn Reflect.get(target, prop, receiver);\n\t},\n\n\tgetOwnPropertyDescriptor(target, prop) {\n\t\tconst descriptor = Reflect.getOwnPropertyDescriptor(target, prop);\n\t\tif (descriptor && 'value' in descriptor) {\n\t\t\t/** @type {import('./types.js').ProxyMetadata} */\n\t\t\tconst metadata = target[STATE_SYMBOL];\n\t\t\tconst s = metadata.s.get(prop);\n\n\t\t\tif (s) {\n\t\t\t\tdescriptor.value = get(s);\n\t\t\t}\n\t\t}\n\n\t\treturn descriptor;\n\t},\n\n\thas(target, prop) {\n\t\tif (prop === STATE_SYMBOL) {\n\t\t\treturn true;\n\t\t}\n\t\t/** @type {import('./types.js').ProxyMetadata} */\n\t\tconst metadata = target[STATE_SYMBOL];\n\t\tconst has = Reflect.has(target, prop);\n\n\t\tlet s = metadata.s.get(prop);\n\t\tif (s !== undefined || (effect_active() && (!has || get_descriptor(target, prop)?.writable))) {\n\t\t\tif (s === undefined) {\n\t\t\t\ts = (metadata.i ? source : mutable_source)(\n\t\t\t\t\thas ? proxy(target[prop], metadata.i, metadata.o) : UNINITIALIZED\n\t\t\t\t);\n\t\t\t\tmetadata.s.set(prop, s);\n\t\t\t}\n\t\t\tconst value = get(s);\n\t\t\tif (value === UNINITIALIZED) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn has;\n\t},\n\n\tset(target, prop, value, receiver) {\n\t\t/** @type {import('./types.js').ProxyMetadata} */\n\t\tconst metadata = target[STATE_SYMBOL];\n\t\tlet s = metadata.s.get(prop);\n\t\t// If we haven't yet created a source for this property, we need to ensure\n\t\t// we do so otherwise if we read it later, then the write won't be tracked and\n\t\t// the heuristics of effects will be different vs if we had read the proxied\n\t\t// object property before writing to that property.\n\t\tif (s === undefined && effect_active()) {\n\t\t\t// the read creates a signal\n\t\t\tuntrack(() => receiver[prop]);\n\t\t\ts = metadata.s.get(prop);\n\t\t}\n\t\tif (s !== undefined) {\n\t\t\tset(s, proxy(value, metadata.i, metadata.o));\n\t\t}\n\t\tconst is_array = metadata.a;\n\t\tconst not_has = !(prop in target);\n\n\t\tif (DEV) {\n\t\t\t// First check ownership of the object that is assigned to.\n\t\t\t// Then, if the new object has owners, widen them with the ones from the current object.\n\t\t\t// If it doesn't have owners that means it's ownerless, and so the assigned object should be, too.\n\t\t\tif (metadata.o) {\n\t\t\t\tcheck_ownership(metadata.o);\n\t\t\t\tfor (const owner in metadata.o) {\n\t\t\t\t\tadd_owner(value, owner);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstrip_owner(value);\n\t\t\t}\n\t\t}\n\n\t\t// variable.length = value -> clear all signals with index >= value\n\t\tif (is_array && prop === 'length') {\n\t\t\tfor (let i = value; i < target.length; i += 1) {\n\t\t\t\tconst s = metadata.s.get(i + '');\n\t\t\t\tif (s !== undefined) set(s, UNINITIALIZED);\n\t\t\t}\n\t\t}\n\n\t\t// Set the new value before updating any signals so that any listeners get the new value\n\t\t// @ts-ignore\n\t\ttarget[prop] = value;\n\n\t\tif (not_has) {\n\t\t\t// If we have mutated an array directly, we might need to\n\t\t\t// signal that length has also changed. Do it before updating metadata\n\t\t\t// to ensure that iterating over the array as a result of a metadata update\n\t\t\t// will not cause the length to be out of sync.\n\t\t\tif (is_array) {\n\t\t\t\tconst ls = metadata.s.get('length');\n\t\t\t\tconst length = target.length;\n\t\t\t\tif (ls !== undefined && ls.v !== length) {\n\t\t\t\t\tset(ls, length);\n\t\t\t\t}\n\t\t\t}\n\t\t\tupdate_version(metadata.v);\n\t\t}\n\n\t\treturn true;\n\t},\n\n\townKeys(target) {\n\t\t/** @type {import('./types.js').ProxyMetadata} */\n\t\tconst metadata = target[STATE_SYMBOL];\n\n\t\tget(metadata.v);\n\t\treturn Reflect.ownKeys(target);\n\t}\n};\n\nif (DEV) {\n\tstate_proxy_handler.setPrototypeOf = () => {\n\t\tthrow new Error('Cannot set prototype of $state object');\n\t};\n}\n", "import { run_all } from '../../common.js';\n\nlet is_task_queued = false;\nlet is_raf_queued = false;\n\n/** @type {Array<() => void>} */\nlet current_queued_tasks = [];\n/** @type {Array<() => void>} */\nlet current_raf_tasks = [];\n\nfunction process_task() {\n\tis_task_queued = false;\n\tconst tasks = current_queued_tasks.slice();\n\tcurrent_queued_tasks = [];\n\trun_all(tasks);\n}\n\nfunction process_raf_task() {\n\tis_raf_queued = false;\n\tconst tasks = current_raf_tasks.slice();\n\tcurrent_raf_tasks = [];\n\trun_all(tasks);\n}\n\n/**\n * @param {() => void} fn\n * @returns {void}\n */\nexport function schedule_task(fn) {\n\tif (!is_task_queued) {\n\t\tis_task_queued = true;\n\t\tsetTimeout(process_task, 0);\n\t}\n\tcurrent_queued_tasks.push(fn);\n}\n\n/**\n * @param {() => void} fn\n * @returns {void}\n */\nexport function schedule_raf_task(fn) {\n\tif (!is_raf_queued) {\n\t\tis_raf_queued = true;\n\t\trequestAnimationFrame(process_raf_task);\n\t}\n\tcurrent_raf_tasks.push(fn);\n}\n\n/**\n * Synchronously run any queued tasks.\n */\nexport function flush_tasks() {\n\tif (is_task_queued) {\n\t\tprocess_task();\n\t}\n\tif (is_raf_queued) {\n\t\tprocess_raf_task();\n\t}\n}\n", "import { DEV } from 'esm-env';\nimport { run_all } from '../common.js';\nimport {\n\tarray_prototype,\n\tget_descriptors,\n\tget_prototype_of,\n\tis_array,\n\tis_frozen,\n\tobject_freeze,\n\tobject_prototype\n} from './utils.js';\nimport { unstate } from './proxy.js';\nimport { pre_effect } from './reactivity/computations.js';\nimport {\n\tEACH_BLOCK,\n\tIF_BLOCK,\n\tEFFECT,\n\tPRE_EFFECT,\n\tRENDER_EFFECT,\n\tDIRTY,\n\tUNINITIALIZED,\n\tMAYBE_DIRTY,\n\tCLEAN,\n\tDERIVED,\n\tUNOWNED,\n\tDESTROYED,\n\tINERT,\n\tMANAGED,\n\tSOURCE,\n\tSTATE_SYMBOL\n} from './constants.js';\nimport { flush_tasks } from './dom/task.js';\nimport { add_owner } from './dev/ownership.js';\n\nconst IS_EFFECT = EFFECT | PRE_EFFECT | RENDER_EFFECT;\n\nconst FLUSH_MICROTASK = 0;\nconst FLUSH_SYNC = 1;\n\n// Used for controlling the flush of effects.\nlet current_scheduler_mode = FLUSH_MICROTASK;\n// Used for handling scheduling\nlet is_micro_task_queued = false;\nlet is_flushing_effect = false;\n// Used for $inspect\nexport let is_batching_effect = false;\nlet is_inspecting_signal = false;\n\n// Handle effect queues\n\n/** @type {import('./types.js').EffectSignal[]} */\nlet current_queued_pre_and_render_effects = [];\n\n/** @type {import('./types.js').EffectSignal[]} */\nlet current_queued_effects = [];\n\nlet flush_count = 0;\n// Handle signal reactivity tree dependencies and consumer\n\n/** @type {null | import('./types.js').ComputationSignal} */\nexport let current_consumer = null;\n\n/** @type {null | import('./types.js').EffectSignal} */\nexport let current_effect = null;\n\n/** @type {null | import('./types.js').Signal[]} */\nlet current_dependencies = null;\nlet current_dependencies_index = 0;\n/**\n * Tracks writes that the effect it's executed in doesn't listen to yet,\n * so that the dependency can be added to the effect later on if it then reads it\n * @type {null | import('./types.js').Signal[]}\n */\nlet current_untracked_writes = null;\n/** @type {null | import('./types.js').SignalDebug} */\nlet last_inspected_signal = null;\n/** If `true`, `get`ting the signal should not register it as a dependency */\nexport let current_untracking = false;\n/** Exists to opt out of the mutation validation for stores which may be set for the first time during a derivation */\nlet ignore_mutation_validation = false;\n/** @param {boolean} value */\nexport function set_ignore_mutation_validation(value) {\n\tignore_mutation_validation = value;\n}\n\n// If we are working with a get() chain that has no active container,\n// to prevent memory leaks, we skip adding the consumer.\nlet current_skip_consumer = false;\n// Handle collecting all signals which are read during a specific time frame\nexport let is_signals_recorded = false;\nlet captured_signals = new Set();\n\n/** @type {Function | null} */\nexport let inspect_fn = null;\n\n/** @type {Array<import('./types.js').SignalDebug>} */\nlet inspect_captured_signals = [];\n\n// Handle rendering tree blocks and anchors\n/** @type {null | import('./types.js').Block} */\nexport let current_block = null;\n// Handling runtime component context\n\n/** @type {import('./types.js').ComponentContext | null} */\nexport let current_component_context = null;\n\nexport let updating_derived = false;\n\n/**\n * @param {null | import('./types.js').ComponentContext} context\n * @returns {boolean}\n */\nfunction is_runes(context) {\n\tconst component_context = context || current_component_context;\n\treturn component_context !== null && component_context.r;\n}\n\n/**\n * @param {import('./types.js').ProxyStateObject} target\n * @param {string | symbol} prop\n * @param {any} receiver\n */\nexport function batch_inspect(target, prop, receiver) {\n\tconst value = Reflect.get(target, prop, receiver);\n\t/**\n\t * @this {any}\n\t */\n\treturn function () {\n\t\tconst previously_batching_effect = is_batching_effect;\n\t\tis_batching_effect = true;\n\t\ttry {\n\t\t\treturn Reflect.apply(value, this, arguments);\n\t\t} finally {\n\t\t\tis_batching_effect = previously_batching_effect;\n\t\t\tif (last_inspected_signal !== null && !is_inspecting_signal) {\n\t\t\t\tis_inspecting_signal = true;\n\t\t\t\ttry {\n\t\t\t\t\tfor (const fn of last_inspected_signal.inspect) {\n\t\t\t\t\t\tfn();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tis_inspecting_signal = false;\n\t\t\t\t}\n\t\t\t\tlast_inspected_signal = null;\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * @template V\n * @param {import('./types.js').Signal<V>} signal\n * @returns {boolean}\n */\nfunction is_signal_dirty(signal) {\n\tconst flags = signal.f;\n\tif ((flags & DIRTY) !== 0 || signal.v === UNINITIALIZED) {\n\t\treturn true;\n\t}\n\tif ((flags & MAYBE_DIRTY) !== 0) {\n\t\tconst dependencies = /** @type {import('./types.js').ComputationSignal<V>} **/ (signal).d;\n\t\tif (dependencies !== null) {\n\t\t\tconst length = dependencies.length;\n\t\t\tlet i;\n\t\t\tfor (i = 0; i < length; i++) {\n\t\t\t\tconst dependency = dependencies[i];\n\t\t\t\tif ((dependency.f & MAYBE_DIRTY) !== 0 && !is_signal_dirty(dependency)) {\n\t\t\t\t\tset_signal_status(dependency, CLEAN);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// The flags can be marked as dirty from the above is_signal_dirty call.\n\t\t\t\tif ((dependency.f & DIRTY) !== 0) {\n\t\t\t\t\tif ((dependency.f & DERIVED) !== 0) {\n\t\t\t\t\t\tupdate_derived(\n\t\t\t\t\t\t\t/** @type {import('./types.js').ComputationSignal<V>} **/ (dependency),\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t);\n\t\t\t\t\t\t// Might have been mutated from above get.\n\t\t\t\t\t\tif ((signal.f & DIRTY) !== 0) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// If we're workig with an unowned derived signal, then we need to check\n\t\t\t\t// if our dependency write version is higher. If is is then we can assume\n\t\t\t\t// that state has changed to a newer version and thus this unowned signal\n\t\t\t\t// is also dirty.\n\t\t\t\tconst is_unowned = (flags & UNOWNED) !== 0;\n\t\t\t\tconst write_version = signal.w;\n\t\t\t\tconst dep_write_version = dependency.w;\n\t\t\t\tif (is_unowned && dep_write_version > write_version) {\n\t\t\t\t\tsignal.w = dep_write_version;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * @template V\n * @param {import('./types.js').ComputationSignal<V>} signal\n * @returns {V}\n */\nfunction execute_signal_fn(signal) {\n\tconst init = signal.i;\n\tconst flags = signal.f;\n\tconst previous_dependencies = current_dependencies;\n\tconst previous_dependencies_index = current_dependencies_index;\n\tconst previous_untracked_writes = current_untracked_writes;\n\tconst previous_consumer = current_consumer;\n\tconst previous_block = current_block;\n\tconst previous_component_context = current_component_context;\n\tconst previous_skip_consumer = current_skip_consumer;\n\tconst is_render_effect = (flags & RENDER_EFFECT) !== 0;\n\tconst previous_untracking = current_untracking;\n\tcurrent_dependencies = /** @type {null | import('./types.js').Signal[]} */ (null);\n\tcurrent_dependencies_index = 0;\n\tcurrent_untracked_writes = null;\n\tcurrent_consumer = signal;\n\tcurrent_block = signal.b;\n\tcurrent_component_context = signal.x;\n\tcurrent_skip_consumer = !is_flushing_effect && (flags & UNOWNED) !== 0;\n\tcurrent_untracking = false;\n\n\ttry {\n\t\tlet res;\n\t\tif (is_render_effect) {\n\t\t\tres =\n\t\t\t\t/** @type {(block: import('./types.js').Block, signal: import('./types.js').Signal) => V} */ (\n\t\t\t\t\tinit\n\t\t\t\t)(\n\t\t\t\t\t/** @type {import('./types.js').Block} */ (signal.b),\n\t\t\t\t\t/** @type {import('./types.js').Signal} */ (signal)\n\t\t\t\t);\n\t\t} else {\n\t\t\tres = /** @type {() => V} */ (init)();\n\t\t}\n\t\tlet dependencies = /** @type {import('./types.js').Signal<unknown>[]} **/ (signal.d);\n\t\tif (current_dependencies !== null) {\n\t\t\tlet i;\n\t\t\tif (dependencies !== null) {\n\t\t\t\tconst deps_length = dependencies.length;\n\t\t\t\t// Include any dependencies up until the current_dependencies_index.\n\t\t\t\tconst full_current_dependencies =\n\t\t\t\t\tcurrent_dependencies_index === 0\n\t\t\t\t\t\t? current_dependencies\n\t\t\t\t\t\t: dependencies.slice(0, current_dependencies_index).concat(current_dependencies);\n\t\t\t\tconst current_dep_length = full_current_dependencies.length;\n\t\t\t\t// If we have more than 16 elements in the array then use a Set for faster performance\n\t\t\t\t// TODO: evaluate if we should always just use a Set or not here?\n\t\t\t\tconst full_current_dependencies_set =\n\t\t\t\t\tcurrent_dep_length > 16 && deps_length - current_dependencies_index > 1\n\t\t\t\t\t\t? new Set(full_current_dependencies)\n\t\t\t\t\t\t: null;\n\t\t\t\tfor (i = current_dependencies_index; i < deps_length; i++) {\n\t\t\t\t\tconst dependency = dependencies[i];\n\t\t\t\t\tif (\n\t\t\t\t\t\tfull_current_dependencies_set !== null\n\t\t\t\t\t\t\t? !full_current_dependencies_set.has(dependency)\n\t\t\t\t\t\t\t: !full_current_dependencies.includes(dependency)\n\t\t\t\t\t) {\n\t\t\t\t\t\tremove_consumer(signal, dependency);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dependencies !== null && current_dependencies_index > 0) {\n\t\t\t\tdependencies.length = current_dependencies_index + current_dependencies.length;\n\t\t\t\tfor (i = 0; i < current_dependencies.length; i++) {\n\t\t\t\t\tdependencies[current_dependencies_index + i] = current_dependencies[i];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsignal.d = /** @type {import('./types.js').Signal<V>[]} **/ (\n\t\t\t\t\tdependencies = current_dependencies\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (!current_skip_consumer) {\n\t\t\t\tfor (i = current_dependencies_index; i < dependencies.length; i++) {\n\t\t\t\t\tconst dependency = dependencies[i];\n\t\t\t\t\tconst consumers = dependency.c;\n\n\t\t\t\t\tif (consumers === null) {\n\t\t\t\t\t\tdependency.c = [signal];\n\t\t\t\t\t} else if (consumers[consumers.length - 1] !== signal) {\n\t\t\t\t\t\t// TODO: should this be:\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// } else if (!consumers.includes(signal)) {\n\t\t\t\t\t\t//\n\t\t\t\t\t\tconsumers.push(signal);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (dependencies !== null && current_dependencies_index < dependencies.length) {\n\t\t\tremove_consumers(signal, current_dependencies_index);\n\t\t\tdependencies.length = current_dependencies_index;\n\t\t}\n\t\treturn res;\n\t} finally {\n\t\tcurrent_dependencies = previous_dependencies;\n\t\tcurrent_dependencies_index = previous_dependencies_index;\n\t\tcurrent_untracked_writes = previous_untracked_writes;\n\t\tcurrent_consumer = previous_consumer;\n\t\tcurrent_block = previous_block;\n\t\tcurrent_component_context = previous_component_context;\n\t\tcurrent_skip_consumer = previous_skip_consumer;\n\t\tcurrent_untracking = previous_untracking;\n\t}\n}\n\n/**\n * @template V\n * @param {import('./types.js').ComputationSignal<V>} signal\n * @param {import('./types.js').Signal<V>} dependency\n * @returns {void}\n */\nfunction remove_consumer(signal, dependency) {\n\tconst consumers = dependency.c;\n\tlet consumers_length = 0;\n\tif (consumers !== null) {\n\t\tconsumers_length = consumers.length - 1;\n\t\tconst index = consumers.indexOf(signal);\n\t\tif (index !== -1) {\n\t\t\tif (consumers_length === 0) {\n\t\t\t\tdependency.c = null;\n\t\t\t} else {\n\t\t\t\t// Swap with last element and then remove.\n\t\t\t\tconsumers[index] = consumers[consumers_length];\n\t\t\t\tconsumers.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (consumers_length === 0 && (dependency.f & UNOWNED) !== 0) {\n\t\t// If the signal is unowned then we need to make sure to change it to dirty.\n\t\tset_signal_status(dependency, DIRTY);\n\t\tremove_consumers(/** @type {import('./types.js').ComputationSignal<V>} **/ (dependency), 0);\n\t}\n}\n\n/**\n * @template V\n * @param {import('./types.js').ComputationSignal<V>} signal\n * @param {number} start_index\n * @returns {void}\n */\nfunction remove_consumers(signal, start_index) {\n\tconst dependencies = signal.d;\n\tif (dependencies !== null) {\n\t\tconst active_dependencies = start_index === 0 ? null : dependencies.slice(0, start_index);\n\t\tlet i;\n\t\tfor (i = start_index; i < dependencies.length; i++) {\n\t\t\tconst dependency = dependencies[i];\n\t\t\t// Avoid removing a consumer if we know that it is active (start_index will not be 0)\n\t\t\tif (active_dependencies === null || !active_dependencies.includes(dependency)) {\n\t\t\t\tremove_consumer(signal, dependency);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @template V\n * @param {import('./types.js').ComputationSignal<V>} signal\n * @returns {void}\n */\nfunction destroy_references(signal) {\n\tconst references = signal.r;\n\tsignal.r = null;\n\tif (references !== null) {\n\t\tlet i;\n\t\tfor (i = 0; i < references.length; i++) {\n\t\t\tdestroy_signal(references[i]);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('./types.js').Block} block\n * @param {unknown} error\n * @returns {void}\n */\nfunction report_error(block, error) {\n\t/** @type {import('./types.js').Block | null} */\n\tlet current_block = block;\n\n\tif (current_block !== null) {\n\t\tthrow error;\n\t}\n}\n\n/**\n * @param {import('./types.js').EffectSignal} signal\n * @returns {void}\n */\nexport function execute_effect(signal) {\n\tif ((signal.f & DESTROYED) !== 0) {\n\t\treturn;\n\t}\n\tconst teardown = signal.v;\n\tconst previous_effect = current_effect;\n\tcurrent_effect = signal;\n\n\ttry {\n\t\tdestroy_references(signal);\n\t\tif (teardown !== null) {\n\t\t\tteardown();\n\t\t}\n\t\tconst possible_teardown = execute_signal_fn(signal);\n\t\tif (typeof possible_teardown === 'function') {\n\t\t\tsignal.v = possible_teardown;\n\t\t}\n\t} catch (error) {\n\t\tconst block = signal.b;\n\t\tif (block !== null) {\n\t\t\treport_error(block, error);\n\t\t} else {\n\t\t\tthrow error;\n\t\t}\n\t} finally {\n\t\tcurrent_effect = previous_effect;\n\t}\n\tconst component_context = signal.x;\n\tif (\n\t\tis_runes(component_context) && // Don't rerun pre effects more than once to accomodate for \"$: only runs once\" behavior\n\t\t(signal.f & PRE_EFFECT) !== 0 &&\n\t\tcurrent_queued_pre_and_render_effects.length > 0\n\t) {\n\t\tflush_local_pre_effects(component_context);\n\t}\n}\n\nfunction infinite_loop_guard() {\n\tif (flush_count > 100) {\n\t\tflush_count = 0;\n\t\tthrow new Error(\n\t\t\t'ERR_SVELTE_TOO_MANY_UPDATES' +\n\t\t\t\t(DEV\n\t\t\t\t\t? ': Maximum update depth exceeded. This can happen when a reactive block or effect ' +\n\t\t\t\t\t\t'repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops.'\n\t\t\t\t\t: '')\n\t\t);\n\t}\n\tflush_count++;\n}\n\n/**\n * @param {Array<import('./types.js').EffectSignal>} effects\n * @returns {void}\n */\nfunction flush_queued_effects(effects) {\n\tconst length = effects.length;\n\tif (length > 0) {\n\t\tinfinite_loop_guard();\n\t\tconst previously_flushing_effect = is_flushing_effect;\n\t\tis_flushing_effect = true;\n\t\ttry {\n\t\t\tlet i;\n\t\t\tfor (i = 0; i < length; i++) {\n\t\t\t\tconst signal = effects[i];\n\t\t\t\tconst flags = signal.f;\n\t\t\t\tif ((flags & (DESTROYED | INERT)) === 0) {\n\t\t\t\t\tif (is_signal_dirty(signal)) {\n\t\t\t\t\t\tset_signal_status(signal, CLEAN);\n\t\t\t\t\t\texecute_effect(signal);\n\t\t\t\t\t} else if ((flags & MAYBE_DIRTY) !== 0) {\n\t\t\t\t\t\tset_signal_status(signal, CLEAN);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tis_flushing_effect = previously_flushing_effect;\n\t\t}\n\n\t\teffects.length = 0;\n\t}\n}\n\nfunction process_microtask() {\n\tis_micro_task_queued = false;\n\tif (flush_count > 101) {\n\t\treturn;\n\t}\n\tconst previous_queued_pre_and_render_effects = current_queued_pre_and_render_effects;\n\tconst previous_queued_effects = current_queued_effects;\n\tcurrent_queued_pre_and_render_effects = [];\n\tcurrent_queued_effects = [];\n\tflush_queued_effects(previous_queued_pre_and_render_effects);\n\tflush_queued_effects(previous_queued_effects);\n\tif (!is_micro_task_queued) {\n\t\tflush_count = 0;\n\t}\n}\n\n/**\n * @param {import('./types.js').EffectSignal} signal\n * @param {boolean} sync\n * @returns {void}\n */\nexport function schedule_effect(signal, sync) {\n\tconst flags = signal.f;\n\tif (sync) {\n\t\tconst previously_flushing_effect = is_flushing_effect;\n\t\ttry {\n\t\t\tis_flushing_effect = true;\n\t\t\texecute_effect(signal);\n\t\t\tset_signal_status(signal, CLEAN);\n\t\t} finally {\n\t\t\tis_flushing_effect = previously_flushing_effect;\n\t\t}\n\t} else {\n\t\tif (current_scheduler_mode === FLUSH_MICROTASK) {\n\t\t\tif (!is_micro_task_queued) {\n\t\t\t\tis_micro_task_queued = true;\n\t\t\t\tqueueMicrotask(process_microtask);\n\t\t\t}\n\t\t}\n\t\tif ((flags & EFFECT) !== 0) {\n\t\t\tcurrent_queued_effects.push(signal);\n\t\t\t// Prevent any nested user effects from potentially triggering\n\t\t\t// before this effect is scheduled. We know they will be destroyed\n\t\t\t// so we can make them inert to avoid having to find them in the\n\t\t\t// queue and remove them.\n\t\t\tif ((flags & MANAGED) === 0) {\n\t\t\t\tmark_subtree_children_inert(signal, true);\n\t\t\t}\n\t\t} else {\n\t\t\t// We need to ensure we insert the signal in the right topological order. In other words,\n\t\t\t// we need to evaluate where to insert the signal based off its level and whether or not it's\n\t\t\t// a pre-effect and within the same block. By checking the signals in the queue in reverse order\n\t\t\t// we can find the right place quickly. TODO: maybe opt to use a linked list rather than an array\n\t\t\t// for these operations.\n\t\t\tconst length = current_queued_pre_and_render_effects.length;\n\t\t\tlet should_append = length === 0;\n\n\t\t\tif (!should_append) {\n\t\t\t\tconst target_level = signal.l;\n\t\t\t\tconst target_block = signal.b;\n\t\t\t\tconst is_pre_effect = (flags & PRE_EFFECT) !== 0;\n\t\t\t\tlet target_signal;\n\t\t\t\tlet is_target_pre_effect;\n\t\t\t\tlet i = length;\n\t\t\t\twhile (true) {\n\t\t\t\t\ttarget_signal = current_queued_pre_and_render_effects[--i];\n\t\t\t\t\tif (target_signal.l <= target_level) {\n\t\t\t\t\t\tif (i + 1 === length) {\n\t\t\t\t\t\t\tshould_append = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tis_target_pre_effect = (target_signal.f & PRE_EFFECT) !== 0;\n\t\t\t\t\t\t\tif (target_signal.b !== target_block || (is_target_pre_effect && !is_pre_effect)) {\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcurrent_queued_pre_and_render_effects.splice(i, 0, signal);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\tcurrent_queued_pre_and_render_effects.unshift(signal);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (should_append) {\n\t\t\t\tcurrent_queued_pre_and_render_effects.push(signal);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @returns {void}\n */\nexport function flush_local_render_effects() {\n\tconst effects = [];\n\tfor (let i = 0; i < current_queued_pre_and_render_effects.length; i++) {\n\t\tconst effect = current_queued_pre_and_render_effects[i];\n\t\tif ((effect.f & RENDER_EFFECT) !== 0 && effect.x === current_component_context) {\n\t\t\teffects.push(effect);\n\t\t\tcurrent_queued_pre_and_render_effects.splice(i, 1);\n\t\t\ti--;\n\t\t}\n\t}\n\tflush_queued_effects(effects);\n}\n\n/**\n * @param {null | import('./types.js').ComponentContext} context\n * @returns {void}\n */\nexport function flush_local_pre_effects(context) {\n\tconst effects = [];\n\tfor (let i = 0; i < current_queued_pre_and_render_effects.length; i++) {\n\t\tconst effect = current_queued_pre_and_render_effects[i];\n\t\tif ((effect.f & PRE_EFFECT) !== 0 && effect.x === context) {\n\t\t\teffects.push(effect);\n\t\t\tcurrent_queued_pre_and_render_effects.splice(i, 1);\n\t\t\ti--;\n\t\t}\n\t}\n\tflush_queued_effects(effects);\n}\n\n/**\n * Synchronously flushes any pending state changes and those that result from it.\n * @param {() => void} [fn]\n * @returns {void}\n */\nexport function flushSync(fn) {\n\tflush_sync(fn);\n}\n\n/**\n * Internal version of `flushSync` with the option to not flush previous effects.\n * Returns the result of the passed function, if given.\n * @param {() => any} [fn]\n * @param {boolean} [flush_previous]\n * @returns {any}\n */\nexport function flush_sync(fn, flush_previous = true) {\n\tconst previous_scheduler_mode = current_scheduler_mode;\n\tconst previous_queued_pre_and_render_effects = current_queued_pre_and_render_effects;\n\tconst previous_queued_effects = current_queued_effects;\n\tlet result;\n\n\ttry {\n\t\tinfinite_loop_guard();\n\t\t/** @type {import('./types.js').EffectSignal[]} */\n\t\tconst pre_and_render_effects = [];\n\n\t\t/** @type {import('./types.js').EffectSignal[]} */\n\t\tconst effects = [];\n\t\tcurrent_scheduler_mode = FLUSH_SYNC;\n\t\tcurrent_queued_pre_and_render_effects = pre_and_render_effects;\n\t\tcurrent_queued_effects = effects;\n\t\tif (flush_previous) {\n\t\t\tflush_queued_effects(previous_queued_pre_and_render_effects);\n\t\t\tflush_queued_effects(previous_queued_effects);\n\t\t}\n\t\tif (fn !== undefined) {\n\t\t\tresult = fn();\n\t\t}\n\t\tif (current_queued_pre_and_render_effects.length > 0 || effects.length > 0) {\n\t\t\tflushSync();\n\t\t}\n\t\tflush_tasks();\n\t\tflush_count = 0;\n\t} finally {\n\t\tcurrent_scheduler_mode = previous_scheduler_mode;\n\t\tcurrent_queued_pre_and_render_effects = previous_queued_pre_and_render_effects;\n\t\tcurrent_queued_effects = previous_queued_effects;\n\t}\n\n\treturn result;\n}\n\n/**\n * Returns a promise that resolves once any pending state changes have been applied.\n * @returns {Promise<void>}\n */\nexport async function tick() {\n\tawait Promise.resolve();\n\t// By calling flushSync we guarantee that any pending state changes are applied after one tick.\n\t// TODO look into whether we can make flushing subsequent updates synchronously in the future.\n\tflushSync();\n}\n\n/**\n * @template V\n * @param {import('./types.js').ComputationSignal<V>} signal\n * @param {boolean} force_schedule\n * @returns {void}\n */\nfunction update_derived(signal, force_schedule) {\n\tconst previous_updating_derived = updating_derived;\n\tupdating_derived = true;\n\tdestroy_references(signal);\n\tconst value = execute_signal_fn(signal);\n\tupdating_derived = previous_updating_derived;\n\tconst status =\n\t\t(current_skip_consumer || (signal.f & UNOWNED) !== 0) && signal.d !== null\n\t\t\t? MAYBE_DIRTY\n\t\t\t: CLEAN;\n\tset_signal_status(signal, status);\n\tconst equals = /** @type {import('./types.js').EqualsFunctions} */ (signal.e);\n\tif (!equals(value, signal.v)) {\n\t\tsignal.v = value;\n\t\tmark_signal_consumers(signal, DIRTY, force_schedule);\n\n\t\t// @ts-expect-error\n\t\tif (DEV && signal.inspect && force_schedule) {\n\t\t\tfor (const fn of /** @type {import('./types.js').SignalDebug} */ (signal).inspect) fn();\n\t\t}\n\t}\n}\n\n/**\n * @template V\n * @param {import('./types.js').Signal<V>} signal\n * @returns {V}\n */\nexport function get(signal) {\n\t// @ts-expect-error\n\tif (DEV && signal.inspect && inspect_fn) {\n\t\t/** @type {import('./types.js').SignalDebug} */ (signal).inspect.add(inspect_fn);\n\t\t// @ts-expect-error\n\t\tinspect_captured_signals.push(signal);\n\t}\n\n\tconst flags = signal.f;\n\tif ((flags & DESTROYED) !== 0) {\n\t\treturn signal.v;\n\t}\n\n\tif (is_signals_recorded) {\n\t\tcaptured_signals.add(signal);\n\t}\n\n\t// Register the dependency on the current consumer signal.\n\tif (current_consumer !== null && (current_consumer.f & MANAGED) === 0 && !current_untracking) {\n\t\tconst unowned = (current_consumer.f & UNOWNED) !== 0;\n\t\tconst dependencies = current_consumer.d;\n\t\tif (\n\t\t\tcurrent_dependencies === null &&\n\t\t\tdependencies !== null &&\n\t\t\tdependencies[current_dependencies_index] === signal &&\n\t\t\t!(unowned && current_effect !== null)\n\t\t) {\n\t\t\tcurrent_dependencies_index++;\n\t\t} else if (\n\t\t\tdependencies === null ||\n\t\t\tcurrent_dependencies_index === 0 ||\n\t\t\tdependencies[current_dependencies_index - 1] !== signal\n\t\t) {\n\t\t\tif (current_dependencies === null) {\n\t\t\t\tcurrent_dependencies = [signal];\n\t\t\t} else {\n\t\t\t\tcurrent_dependencies.push(signal);\n\t\t\t}\n\t\t}\n\t\tif (\n\t\t\tcurrent_untracked_writes !== null &&\n\t\t\tcurrent_effect !== null &&\n\t\t\t(current_effect.f & CLEAN) !== 0 &&\n\t\t\t(current_effect.f & MANAGED) === 0 &&\n\t\t\tcurrent_untracked_writes.includes(signal)\n\t\t) {\n\t\t\tset_signal_status(current_effect, DIRTY);\n\t\t\tschedule_effect(current_effect, false);\n\t\t}\n\t}\n\n\tif ((flags & DERIVED) !== 0 && is_signal_dirty(signal)) {\n\t\tif (DEV) {\n\t\t\t// we want to avoid tracking indirect dependencies\n\t\t\tconst previous_inspect_fn = inspect_fn;\n\t\t\tinspect_fn = null;\n\t\t\tupdate_derived(/** @type {import('./types.js').ComputationSignal<V>} **/ (signal), false);\n\t\t\tinspect_fn = previous_inspect_fn;\n\t\t} else {\n\t\t\tupdate_derived(/** @type {import('./types.js').ComputationSignal<V>} **/ (signal), false);\n\t\t}\n\t}\n\treturn signal.v;\n}\n\n/**\n * @template V\n * @param {import('./types.js').Signal<V>} signal\n * @param {V} value\n * @returns {V}\n */\nexport function set(signal, value) {\n\tset_signal_value(signal, value);\n\treturn value;\n}\n\n/**\n * @template V\n * @param {import('./types.js').Signal<V>} signal\n * @param {V} value\n * @returns {void}\n */\nexport function set_sync(signal, value) {\n\tflushSync(() => set(signal, value));\n}\n\n/**\n * Invokes a function and captures all signals that are read during the invocation,\n * then invalidates them.\n * @param {() => any} fn\n */\nexport function invalidate_inner_signals(fn) {\n\tvar previous_is_signals_recorded = is_signals_recorded;\n\tvar previous_captured_signals = captured_signals;\n\tis_signals_recorded = true;\n\tcaptured_signals = new Set();\n\tvar captured = captured_signals;\n\tvar signal;\n\ttry {\n\t\tuntrack(fn);\n\t} finally {\n\t\tis_signals_recorded = previous_is_signals_recorded;\n\t\tif (is_signals_recorded) {\n\t\t\tfor (signal of captured_signals) {\n\t\t\t\tprevious_captured_signals.add(signal);\n\t\t\t}\n\t\t}\n\t\tcaptured_signals = previous_captured_signals;\n\t}\n\tfor (signal of captured) {\n\t\tmutate(signal, null /* doesnt matter */);\n\t}\n}\n\n/**\n * @template V\n * @param {import('./types.js').Signal<V>} source\n * @param {V} value\n */\nexport function mutate(source, value) {\n\tset_signal_value(\n\t\tsource,\n\t\tuntrack(() => get(source))\n\t);\n\treturn value;\n}\n\n/**\n * @param {import('./types.js').ComputationSignal} signal\n * @param {boolean} inert\n * @param {Set<import('./types.js').Block>} [visited_blocks]\n * @returns {void}\n */\nfunction mark_subtree_children_inert(signal, inert, visited_blocks) {\n\tconst references = signal.r;\n\tif (references !== null) {\n\t\tlet i;\n\t\tfor (i = 0; i < references.length; i++) {\n\t\t\tconst reference = references[i];\n\t\t\tif ((reference.f & IS_EFFECT) !== 0) {\n\t\t\t\tmark_subtree_inert(reference, inert, visited_blocks);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @param {import('./types.js').ComputationSignal} signal\n * @param {boolean} inert\n * @param {Set<import('./types.js').Block>} [visited_blocks]\n * @returns {void}\n */\nexport function mark_subtree_inert(signal, inert, visited_blocks = new Set()) {\n\tconst flags = signal.f;\n\tconst is_already_inert = (flags & INERT) !== 0;\n\tif (is_already_inert !== inert) {\n\t\tsignal.f ^= INERT;\n\t\tif (!inert && (flags & IS_EFFECT) !== 0 && (flags & CLEAN) === 0) {\n\t\t\tschedule_effect(/** @type {import('./types.js').EffectSignal} */ (signal), false);\n\t\t}\n\t\t// Nested if block effects\n\t\tconst block = signal.b;\n\t\tif (block !== null && !visited_blocks.has(block)) {\n\t\t\tvisited_blocks.add(block);\n\t\t\tconst type = block.t;\n\t\t\tif (type === IF_BLOCK) {\n\t\t\t\tconst condition_effect = block.e;\n\t\t\t\tif (condition_effect !== null && block !== current_block) {\n\t\t\t\t\tmark_subtree_inert(condition_effect, inert, visited_blocks);\n\t\t\t\t}\n\t\t\t\tconst consequent_effect = block.ce;\n\t\t\t\tif (consequent_effect !== null && block.v) {\n\t\t\t\t\tmark_subtree_inert(consequent_effect, inert, visited_blocks);\n\t\t\t\t}\n\t\t\t\tconst alternate_effect = block.ae;\n\t\t\t\tif (alternate_effect !== null && !block.v) {\n\t\t\t\t\tmark_subtree_inert(alternate_effect, inert, visited_blocks);\n\t\t\t\t}\n\t\t\t} else if (type === EACH_BLOCK) {\n\t\t\t\tconst items = block.v;\n\t\t\t\tfor (let { e: each_item_effect } of items) {\n\t\t\t\t\tif (each_item_effect !== null) {\n\t\t\t\t\t\tmark_subtree_inert(each_item_effect, inert, visited_blocks);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmark_subtree_children_inert(signal, inert, visited_blocks);\n}\n\n/**\n * @template V\n * @param {import('./types.js').Signal<V>} signal\n * @param {number} to_status\n * @param {boolean} force_schedule\n * @returns {void}\n */\nfunction mark_signal_consumers(signal, to_status, force_schedule) {\n\tconst runes = is_runes(null);\n\tconst consumers = signal.c;\n\tif (consumers !== null) {\n\t\tconst length = consumers.length;\n\t\tlet i;\n\t\tfor (i = 0; i < length; i++) {\n\t\t\tconst consumer = consumers[i];\n\t\t\tconst flags = consumer.f;\n\t\t\tconst unowned = (flags & UNOWNED) !== 0;\n\t\t\t// We skip any effects that are already dirty (but not unowned). Additionally, we also\n\t\t\t// skip if the consumer is the same as the current effect (except if we're not in runes or we\n\t\t\t// are in force schedule mode).\n\t\t\tif ((!force_schedule || !runes) && consumer === current_effect) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tset_signal_status(consumer, to_status);\n\t\t\t// If the signal is not clean, then skip over it – with the exception of unowned signals that\n\t\t\t// are already maybe dirty. Unowned signals might be dirty because they are not captured as part of an\n\t\t\t// effect.\n\t\t\tconst maybe_dirty = (flags & MAYBE_DIRTY) !== 0;\n\t\t\tif ((flags & CLEAN) !== 0 || (maybe_dirty && unowned)) {\n\t\t\t\tif ((consumer.f & IS_EFFECT) !== 0) {\n\t\t\t\t\tschedule_effect(/** @type {import('./types.js').EffectSignal} */ (consumer), false);\n\t\t\t\t} else {\n\t\t\t\t\tmark_signal_consumers(consumer, MAYBE_DIRTY, force_schedule);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @template V\n * @param {import('./types.js').Signal<V>} signal\n * @param {V} value\n * @returns {void}\n */\nexport function set_signal_value(signal, value) {\n\tif (\n\t\t!current_untracking &&\n\t\t!ignore_mutation_validation &&\n\t\tcurrent_consumer !== null &&\n\t\tis_runes(null) &&\n\t\t(current_consumer.f & DERIVED) !== 0\n\t) {\n\t\tthrow new Error(\n\t\t\t'ERR_SVELTE_UNSAFE_MUTATION' +\n\t\t\t\t(DEV\n\t\t\t\t\t? \": Unsafe mutations during Svelte's render or derived phase are not permitted in runes mode. \" +\n\t\t\t\t\t\t'This can lead to unexpected errors and possibly cause infinite loops.\\n\\nIf this mutation is not meant ' +\n\t\t\t\t\t\t'to be reactive do not use the \"$state\" rune for that declaration.'\n\t\t\t\t\t: '')\n\t\t);\n\t}\n\tif (\n\t\t(signal.f & SOURCE) !== 0 &&\n\t\t!(/** @type {import('./types.js').EqualsFunctions} */ (signal.e)(value, signal.v))\n\t) {\n\t\tsignal.v = value;\n\t\t// Increment write version so that unowned signals can properly track dirtyness\n\t\tsignal.w++;\n\t\t// If the current signal is running for the first time, it won't have any\n\t\t// consumers as we only allocate and assign the consumers after the signal\n\t\t// has fully executed. So in the case of ensuring it registers the consumer\n\t\t// properly for itself, we need to ensure the current effect actually gets\n\t\t// scheduled. i.e:\n\t\t//\n\t\t// $effect(() => x++)\n\t\t//\n\t\t// We additionally want to skip this logic for when ignore_mutation_validation is\n\t\t// true, as stores write to source signal on initialization.\n\t\tif (\n\t\t\tis_runes(null) &&\n\t\t\t!ignore_mutation_validation &&\n\t\t\tcurrent_effect !== null &&\n\t\t\tcurrent_effect.c === null &&\n\t\t\t(current_effect.f & CLEAN) !== 0 &&\n\t\t\t(current_effect.f & MANAGED) === 0\n\t\t) {\n\t\t\tif (current_dependencies !== null && current_dependencies.includes(signal)) {\n\t\t\t\tset_signal_status(current_effect, DIRTY);\n\t\t\t\tschedule_effect(current_effect, false);\n\t\t\t} else {\n\t\t\t\tif (current_untracked_writes === null) {\n\t\t\t\t\tcurrent_untracked_writes = [signal];\n\t\t\t\t} else {\n\t\t\t\t\tcurrent_untracked_writes.push(signal);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmark_signal_consumers(signal, DIRTY, true);\n\n\t\t// @ts-expect-error\n\t\tif (DEV && signal.inspect) {\n\t\t\tif (is_batching_effect) {\n\t\t\t\tlast_inspected_signal = /** @type {import('./types.js').SignalDebug} */ (signal);\n\t\t\t} else {\n\t\t\t\tfor (const fn of /** @type {import('./types.js').SignalDebug} */ (signal).inspect) fn();\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @template V\n * @param {import('./types.js').ComputationSignal<V>} signal\n * @returns {void}\n */\nexport function destroy_signal(signal) {\n\tconst teardown = /** @type {null | (() => void)} */ (signal.v);\n\tconst destroy = signal.y;\n\tconst flags = signal.f;\n\tdestroy_references(signal);\n\tremove_consumers(signal, 0);\n\tsignal.i = signal.r = signal.y = signal.x = signal.b = signal.d = signal.c = null;\n\tset_signal_status(signal, DESTROYED);\n\tif (destroy !== null) {\n\t\tif (is_array(destroy)) {\n\t\t\trun_all(destroy);\n\t\t} else {\n\t\t\tdestroy();\n\t\t}\n\t}\n\tif (teardown !== null && (flags & IS_EFFECT) !== 0) {\n\t\tteardown();\n\t}\n}\n\n/**\n * Use `untrack` to prevent something from being treated as an `$effect`/`$derived` dependency.\n *\n * https://svelte-5-preview.vercel.app/docs/functions#untrack\n * @template T\n * @param {() => T} fn\n * @returns {T}\n */\nexport function untrack(fn) {\n\tconst previous_untracking = current_untracking;\n\ttry {\n\t\tcurrent_untracking = true;\n\t\treturn fn();\n\t} finally {\n\t\tcurrent_untracking = previous_untracking;\n\t}\n}\n\n/**\n * @template V\n * @param {import('./types.js').ComputationSignal<V>} signal\n * @param {() => void} destroy_fn\n * @returns {void}\n */\nexport function push_destroy_fn(signal, destroy_fn) {\n\tlet destroy = signal.y;\n\tif (destroy === null) {\n\t\tsignal.y = destroy_fn;\n\t} else if (is_array(destroy)) {\n\t\tdestroy.push(destroy_fn);\n\t} else {\n\t\tsignal.y = [destroy, destroy_fn];\n\t}\n}\n\nconst STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);\n/**\n * @template V\n * @param {import('./types.js').Signal<V>} signal\n * @param {number} status\n * @returns {void}\n */\nfunction set_signal_status(signal, status) {\n\tsignal.f = (signal.f & STATUS_MASK) | status;\n}\n\n/**\n * @template V\n * @param {V | import('./types.js').Signal<V>} val\n * @returns {val is import('./types.js').Signal<V>}\n */\nexport function is_signal(val) {\n\treturn (\n\t\ttypeof val === 'object' &&\n\t\tval !== null &&\n\t\ttypeof (/** @type {import('./types.js').Signal<V>} */ (val).f) === 'number'\n\t);\n}\n\n/**\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#getcontext\n * @template T\n * @param {any} key\n * @returns {T}\n */\nexport function getContext(key) {\n\tconst context_map = get_or_init_context_map();\n\tconst result = /** @type {T} */ (context_map.get(key));\n\n\tif (DEV) {\n\t\t// @ts-expect-error\n\t\tconst fn = current_component_context?.function;\n\t\tif (fn) {\n\t\t\tadd_owner(result, fn);\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Associates an arbitrary `context` object with the current component and the specified `key`\n * and returns that object. The context is then available to children of the component\n * (including slotted content) with `getContext`.\n *\n * Like lifecycle functions, this must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#setcontext\n * @template T\n * @param {any} key\n * @param {T} context\n * @returns {T}\n */\nexport function setContext(key, context) {\n\tconst context_map = get_or_init_context_map();\n\tcontext_map.set(key, context);\n\treturn context;\n}\n\n/**\n * Checks whether a given `key` has been set in the context of a parent component.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#hascontext\n * @param {any} key\n * @returns {boolean}\n */\nexport function hasContext(key) {\n\tconst context_map = get_or_init_context_map();\n\treturn context_map.has(key);\n}\n\n/**\n * Retrieves the whole context map that belongs to the closest parent component.\n * Must be called during component initialisation. Useful, for example, if you\n * programmatically create a component and want to pass the existing context to it.\n *\n * https://svelte.dev/docs/svelte#getallcontexts\n * @template {Map<any, any>} [T=Map<any, any>]\n * @returns {T}\n */\nexport function getAllContexts() {\n\tconst context_map = get_or_init_context_map();\n\n\tif (DEV) {\n\t\t// @ts-expect-error\n\t\tconst fn = current_component_context?.function;\n\t\tif (fn) {\n\t\t\tfor (const value of context_map.values()) {\n\t\t\t\tadd_owner(value, fn);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn /** @type {T} */ (context_map);\n}\n\n/** @returns {Map<unknown, unknown>} */\nfunction get_or_init_context_map() {\n\tconst component_context = current_component_context;\n\tif (component_context === null) {\n\t\tthrow new Error(\n\t\t\t'ERR_SVELTE_ORPHAN_CONTEXT' +\n\t\t\t\t(DEV ? 'Context can only be used during component initialisation.' : '')\n\t\t);\n\t}\n\treturn (component_context.c ??= new Map(get_parent_context(component_context) || undefined));\n}\n\n/**\n * @param {import('./types.js').ComponentContext} component_context\n * @returns {Map<unknown, unknown> | null}\n */\nfunction get_parent_context(component_context) {\n\tlet parent = component_context.p;\n\twhile (parent !== null) {\n\t\tconst context_map = parent.c;\n\t\tif (context_map !== null) {\n\t\t\treturn context_map;\n\t\t}\n\t\tparent = parent.p;\n\t}\n\treturn null;\n}\n\n/**\n * @param {import('./types.js').Signal<number>} signal\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update(signal, d = 1) {\n\tconst value = get(signal);\n\tset_signal_value(signal, value + d);\n\treturn value;\n}\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_prop(fn, d = 1) {\n\tconst value = fn();\n\tfn(value + d);\n\treturn value;\n}\n\n/**\n * @param {import('./types.js').Signal<number>} signal\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre(signal, d = 1) {\n\tconst value = get(signal) + d;\n\tset_signal_value(signal, value);\n\treturn value;\n}\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre_prop(fn, d = 1) {\n\tconst value = fn() + d;\n\tfn(value);\n\treturn value;\n}\n\n/**\n * @param {Record<string, unknown>} obj\n * @param {string[]} keys\n * @returns {Record<string, unknown>}\n */\nexport function exclude_from_object(obj, keys) {\n\tobj = { ...obj };\n\tlet key;\n\tfor (key of keys) {\n\t\tdelete obj[key];\n\t}\n\treturn obj;\n}\n\n/**\n * @template V\n * @param {V} value\n * @param {V} fallback\n * @returns {V}\n */\nexport function value_or_fallback(value, fallback) {\n\treturn value === undefined ? fallback : value;\n}\n\n/**\n * @param {Record<string, unknown>} props\n * @param {any} runes\n * @param {Function} [fn]\n * @returns {void}\n */\nexport function push(props, runes = false, fn) {\n\tcurrent_component_context = {\n\t\t// exports (and props, if `accessors: true`)\n\t\tx: null,\n\t\t// context\n\t\tc: null,\n\t\t// effects\n\t\te: null,\n\t\t// mounted\n\t\tm: false,\n\t\t// parent\n\t\tp: current_component_context,\n\t\t// signals\n\t\td: null,\n\t\t// props\n\t\ts: props,\n\t\t// runes\n\t\tr: runes,\n\t\t// update_callbacks\n\t\tu: null\n\t};\n\n\tif (DEV) {\n\t\t// component function\n\t\t// @ts-expect-error\n\t\tcurrent_component_context.function = fn;\n\t}\n}\n\n/**\n * @template {Record<string, any>} T\n * @param {T} [component]\n * @returns {T}\n */\nexport function pop(component) {\n\tconst context_stack_item = current_component_context;\n\tif (context_stack_item !== null) {\n\t\tif (component !== undefined) {\n\t\t\tcontext_stack_item.x = component;\n\t\t}\n\t\tconst effects = context_stack_item.e;\n\t\tif (effects !== null) {\n\t\t\tcontext_stack_item.e = null;\n\t\t\tfor (let i = 0; i < effects.length; i++) {\n\t\t\t\tschedule_effect(effects[i], false);\n\t\t\t}\n\t\t}\n\t\tcurrent_component_context = context_stack_item.p;\n\t\tcontext_stack_item.m = true;\n\t}\n\t// Micro-optimization: Don't set .a above to the empty object\n\t// so it can be garbage-collected when the return here is unused\n\treturn component || /** @type {T} */ ({});\n}\n\n/**\n * Possibly traverse an object and read all its properties so that they're all reactive in case this is `$state`.\n * Does only check first level of an object for performance reasons (heuristic should be good for 99% of all cases).\n * @param {any} value\n * @returns {void}\n */\nexport function deep_read_state(value) {\n\tif (typeof value !== 'object' || !value || value instanceof EventTarget) {\n\t\treturn;\n\t}\n\n\tif (STATE_SYMBOL in value) {\n\t\tdeep_read(value);\n\t} else if (!Array.isArray(value)) {\n\t\tfor (let key in value) {\n\t\t\tconst prop = value[key];\n\t\t\tif (typeof prop === 'object' && prop && STATE_SYMBOL in prop) {\n\t\t\t\tdeep_read(prop);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Deeply traverse an object and read all its properties\n * so that they're all reactive in case this is `$state`\n * @param {any} value\n * @param {Set<any>} visited\n * @returns {void}\n */\nexport function deep_read(value, visited = new Set()) {\n\tif (\n\t\ttypeof value === 'object' &&\n\t\tvalue !== null &&\n\t\t// We don't want to traverse DOM elements\n\t\t!(value instanceof EventTarget) &&\n\t\t!visited.has(value)\n\t) {\n\t\tvisited.add(value);\n\t\tfor (let key in value) {\n\t\t\ttry {\n\t\t\t\tdeep_read(value[key], visited);\n\t\t\t} catch (e) {\n\t\t\t\t// continue\n\t\t\t}\n\t\t}\n\t\tconst proto = Object.getPrototypeOf(value);\n\t\tif (\n\t\t\tproto !== Object.prototype &&\n\t\t\tproto !== Array.prototype &&\n\t\t\tproto !== Map.prototype &&\n\t\t\tproto !== Set.prototype &&\n\t\t\tproto !== Date.prototype\n\t\t) {\n\t\t\tconst descriptors = get_descriptors(proto);\n\t\t\tfor (let key in descriptors) {\n\t\t\t\tconst get = descriptors[key].get;\n\t\t\t\tif (get) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tget.call(value);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t// continue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Like `unstate`, but recursively traverses into normal arrays/objects to find potential states in them.\n * @param {any} value\n * @param {Map<any, any>} visited\n * @returns {any}\n */\nfunction deep_unstate(value, visited = new Map()) {\n\tif (typeof value === 'object' && value !== null && !visited.has(value)) {\n\t\tconst unstated = unstate(value);\n\t\tif (unstated !== value) {\n\t\t\tvisited.set(value, unstated);\n\t\t\treturn unstated;\n\t\t}\n\t\tconst prototype = get_prototype_of(value);\n\t\t// Only deeply unstate plain objects and arrays\n\t\tif (prototype === object_prototype || prototype === array_prototype) {\n\t\t\tlet contains_unstated = false;\n\t\t\t/** @type {any} */\n\t\t\tconst nested_unstated = Array.isArray(value) ? [] : {};\n\t\t\tfor (let key in value) {\n\t\t\t\tconst result = deep_unstate(value[key], visited);\n\t\t\t\tnested_unstated[key] = result;\n\t\t\t\tif (result !== value[key]) {\n\t\t\t\t\tcontains_unstated = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvisited.set(value, contains_unstated ? nested_unstated : value);\n\t\t} else {\n\t\t\tvisited.set(value, value);\n\t\t}\n\t}\n\n\treturn visited.get(value) ?? value;\n}\n\n// TODO remove in a few versions, before 5.0 at the latest\nlet warned_inspect_changed = false;\n\n/**\n * @param {() => any[]} get_value\n * @param {Function} [inspect]\n */\n// eslint-disable-next-line no-console\nexport function inspect(get_value, inspect = console.log) {\n\tlet initial = true;\n\n\tpre_effect(() => {\n\t\tconst fn = () => {\n\t\t\tconst value = untrack(() => get_value().map((v) => deep_unstate(v)));\n\t\t\tif (value.length === 2 && typeof value[1] === 'function' && !warned_inspect_changed) {\n\t\t\t\t// eslint-disable-next-line no-console\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'$inspect() API has changed. See https://svelte-5-preview.vercel.app/docs/runes#$inspect for more information.'\n\t\t\t\t);\n\t\t\t\twarned_inspect_changed = true;\n\t\t\t}\n\t\t\tinspect(initial ? 'init' : 'update', ...value);\n\t\t};\n\n\t\tinspect_fn = fn;\n\t\tconst value = get_value();\n\t\tdeep_read(value);\n\t\tinspect_fn = null;\n\n\t\tconst signals = inspect_captured_signals.slice();\n\t\tinspect_captured_signals = [];\n\n\t\tif (initial) {\n\t\t\tfn();\n\t\t\tinitial = false;\n\t\t}\n\n\t\treturn () => {\n\t\t\tfor (const s of signals) {\n\t\t\t\ts.inspect.delete(fn);\n\t\t\t}\n\t\t};\n\t});\n}\n\n/**\n * @template V\n * @param {V} value\n * @returns {import('./types.js').UnwrappedSignal<V>}\n */\nexport function unwrap(value) {\n\tif (is_signal(value)) {\n\t\t// @ts-ignore\n\t\treturn get(value);\n\t}\n\t// @ts-ignore\n\treturn value;\n}\n\nif (DEV) {\n\t/** @param {string} rune */\n\tfunction throw_rune_error(rune) {\n\t\tif (!(rune in globalThis)) {\n\t\t\t// @ts-ignore\n\t\t\tglobalThis[rune] = () => {\n\t\t\t\t// TODO if people start adjusting the \"this can contain runes\" config through v-p-s more, adjust this message\n\t\t\t\tthrow new Error(`${rune} is only available inside .svelte and .svelte.js/ts files`);\n\t\t\t};\n\t\t}\n\t}\n\n\tthrow_rune_error('$state');\n\tthrow_rune_error('$effect');\n\tthrow_rune_error('$derived');\n\tthrow_rune_error('$inspect');\n\tthrow_rune_error('$props');\n}\n\n/**\n * Expects a value that was wrapped with `freeze` and makes it frozen.\n * @template T\n * @param {T} value\n * @returns {Readonly<T>}\n */\nexport function freeze(value) {\n\tif (typeof value === 'object' && value != null && !is_frozen(value)) {\n\t\t// If the object is already proxified, then unstate the value\n\t\tif (STATE_SYMBOL in value) {\n\t\t\treturn object_freeze(unstate(value));\n\t\t}\n\t\t// Otherwise freeze the object\n\t\tobject_freeze(value);\n\t}\n\treturn value;\n}\n", "import { DEV } from 'esm-env';\nimport {\n\tcurrent_block,\n\tcurrent_component_context,\n\tcurrent_consumer,\n\tcurrent_effect,\n\tdestroy_signal,\n\tflush_local_render_effects,\n\tschedule_effect\n} from '../runtime.js';\nimport { default_equals, safe_equal } from './equality.js';\nimport {\n\tDIRTY,\n\tMANAGED,\n\tRENDER_EFFECT,\n\tEFFECT,\n\tPRE_EFFECT,\n\tDERIVED,\n\tUNOWNED,\n\tCLEAN,\n\tUNINITIALIZED\n} from '../constants.js';\n\n/**\n * @template V\n * @param {import('../types.js').SignalFlags} flags\n * @param {V} value\n * @param {import('../types.js').Block | null} block\n */\nfunction create_computation_signal(flags, value, block) {\n\t/** @type {import('../types.js').ComputationSignal<V>} */\n\tconst signal = {\n\t\tb: block,\n\t\tc: null,\n\t\td: null,\n\t\te: null,\n\t\tf: flags,\n\t\tl: 0,\n\t\ti: null,\n\t\tr: null,\n\t\tv: value,\n\t\tw: 0,\n\t\tx: null,\n\t\ty: null\n\t};\n\n\tif (DEV) {\n\t\t// @ts-expect-error\n\t\tsignal.inspect = new Set();\n\t}\n\n\treturn signal;\n}\n\n/**\n * @param {import('../types.js').ComputationSignal} target_signal\n * @param {import('../types.js').ComputationSignal} ref_signal\n * @returns {void}\n */\nexport function push_reference(target_signal, ref_signal) {\n\tconst references = target_signal.r;\n\tif (references === null) {\n\t\ttarget_signal.r = [ref_signal];\n\t} else {\n\t\treferences.push(ref_signal);\n\t}\n}\n\n/**\n * @param {import('../types.js').EffectType} type\n * @param {(() => void | (() => void)) | ((b: import('../types.js').Block) => void | (() => void))} fn\n * @param {boolean} sync\n * @param {null | import('../types.js').Block} block\n * @param {boolean} schedule\n * @returns {import('../types.js').EffectSignal}\n */\nfunction internal_create_effect(type, fn, sync, block, schedule) {\n\tconst signal = create_computation_signal(type | DIRTY, null, block);\n\tsignal.i = fn;\n\tsignal.x = current_component_context;\n\tif (current_effect !== null) {\n\t\tsignal.l = current_effect.l + 1;\n\t\tif ((type & MANAGED) === 0) {\n\t\t\tpush_reference(current_effect, signal);\n\t\t}\n\t}\n\tif (schedule) {\n\t\tschedule_effect(signal, sync);\n\t}\n\treturn signal;\n}\n\n/**\n * @returns {boolean}\n */\nexport function effect_active() {\n\treturn current_effect ? (current_effect.f & MANAGED) === 0 : false;\n}\n\n/**\n * Internal representation of `$effect(...)`\n * @param {() => void | (() => void)} fn\n * @returns {import('../types.js').EffectSignal}\n */\nexport function user_effect(fn) {\n\tif (current_effect === null) {\n\t\tthrow new Error(\n\t\t\t'ERR_SVELTE_ORPHAN_EFFECT' +\n\t\t\t\t(DEV ? ': The Svelte $effect rune can only be used during component initialisation.' : '')\n\t\t);\n\t}\n\n\tconst apply_component_effect_heuristics =\n\t\tcurrent_effect.f & RENDER_EFFECT &&\n\t\tcurrent_component_context !== null &&\n\t\t!current_component_context.m;\n\n\tconst effect = internal_create_effect(\n\t\tEFFECT,\n\t\tfn,\n\t\tfalse,\n\t\tcurrent_block,\n\t\t!apply_component_effect_heuristics\n\t);\n\n\tif (apply_component_effect_heuristics) {\n\t\tconst context = /** @type {import('../types.js').ComponentContext} */ (\n\t\t\tcurrent_component_context\n\t\t);\n\t\t(context.e ??= []).push(effect);\n\t}\n\n\treturn effect;\n}\n\n/**\n * Internal representation of `$effect.root(...)`\n * @param {() => void | (() => void)} fn\n * @returns {() => void}\n */\nexport function user_root_effect(fn) {\n\tconst effect = render_effect(fn, current_block, true);\n\treturn () => {\n\t\tdestroy_signal(effect);\n\t};\n}\n\n/**\n * @param {() => void | (() => void)} fn\n * @returns {import('../types.js').EffectSignal}\n */\nexport function effect(fn) {\n\treturn internal_create_effect(EFFECT, fn, false, current_block, true);\n}\n\n/**\n * @param {() => void | (() => void)} fn\n * @returns {import('../types.js').EffectSignal}\n */\nexport function managed_effect(fn) {\n\treturn internal_create_effect(EFFECT | MANAGED, fn, false, current_block, true);\n}\n\n/**\n * @param {() => void | (() => void)} fn\n * @param {boolean} sync\n * @returns {import('../types.js').EffectSignal}\n */\nexport function managed_pre_effect(fn, sync) {\n\treturn internal_create_effect(PRE_EFFECT | MANAGED, fn, sync, current_block, true);\n}\n\n/**\n * Internal representation of `$effect.pre(...)`\n * @param {() => void | (() => void)} fn\n * @returns {import('../types.js').EffectSignal}\n */\nexport function pre_effect(fn) {\n\tif (current_effect === null) {\n\t\tthrow new Error(\n\t\t\t'ERR_SVELTE_ORPHAN_EFFECT' +\n\t\t\t\t(DEV\n\t\t\t\t\t? ': The Svelte $effect.pre rune can only be used during component initialisation.'\n\t\t\t\t\t: '')\n\t\t);\n\t}\n\tconst sync = current_effect !== null && (current_effect.f & RENDER_EFFECT) !== 0;\n\treturn internal_create_effect(\n\t\tPRE_EFFECT,\n\t\t() => {\n\t\t\tconst val = fn();\n\t\t\tflush_local_render_effects();\n\t\t\treturn val;\n\t\t},\n\t\tsync,\n\t\tcurrent_block,\n\t\ttrue\n\t);\n}\n\n/**\n * This effect is used to ensure binding are kept in sync. We use a pre effect to ensure we run before the\n * bindings which are in later effects. However, we don't use a pre_effect directly as we don't want to flush anything.\n *\n * @param {() => void | (() => void)} fn\n * @returns {import('../types.js').EffectSignal}\n */\nexport function invalidate_effect(fn) {\n\treturn internal_create_effect(PRE_EFFECT, fn, true, current_block, true);\n}\n\n/**\n * @template {import('../types.js').Block} B\n * @param {(block: B) => void | (() => void)} fn\n * @param {any} block\n * @param {any} managed\n * @param {any} sync\n * @returns {import('../types.js').EffectSignal}\n */\nexport function render_effect(fn, block = current_block, managed = false, sync = true) {\n\tlet flags = RENDER_EFFECT;\n\tif (managed) {\n\t\tflags |= MANAGED;\n\t}\n\treturn internal_create_effect(flags, /** @type {any} */ (fn), sync, block, true);\n}\n\n/**\n * @template V\n * @param {() => V} fn\n * @returns {import('../types.js').ComputationSignal<V>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function derived(fn) {\n\tconst is_unowned = current_effect === null;\n\tconst flags = is_unowned ? DERIVED | UNOWNED : DERIVED;\n\tconst signal = /** @type {import('../types.js').ComputationSignal<V>} */ (\n\t\tcreate_computation_signal(flags | CLEAN, UNINITIALIZED, current_block)\n\t);\n\tsignal.i = fn;\n\tsignal.e = default_equals;\n\tif (current_consumer !== null) {\n\t\tpush_reference(current_consumer, signal);\n\t}\n\treturn signal;\n}\n\n/**\n * @template V\n * @param {() => V} fn\n * @returns {import('../types.js').ComputationSignal<V>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function derived_safe_equal(fn) {\n\tconst signal = derived(fn);\n\tsignal.e = safe_equal;\n\treturn signal;\n}\n", "export const EACH_ITEM_REACTIVE = 1;\nexport const EACH_INDEX_REACTIVE = 1 << 1;\nexport const EACH_KEYED = 1 << 2;\n\n/** See EachBlock interface metadata.is_controlled for an explanation what this is */\nexport const EACH_IS_CONTROLLED = 1 << 3;\nexport const EACH_IS_ANIMATED = 1 << 4;\nexport const EACH_IS_STRICT_EQUALS = 1 << 6;\n\nexport const PROPS_IS_IMMUTABLE = 1;\nexport const PROPS_IS_RUNES = 1 << 1;\nexport const PROPS_IS_UPDATED = 1 << 2;\nexport const PROPS_IS_LAZY_INITIAL = 1 << 3;\n\n/** List of Element events that will be delegated */\nexport const DelegatedEvents = [\n\t'beforeinput',\n\t'click',\n\t'dblclick',\n\t'contextmenu',\n\t'focusin',\n\t'focusout',\n\t// 'input', This conflicts with bind:input\n\t'keydown',\n\t'keyup',\n\t'mousedown',\n\t'mousemove',\n\t'mouseout',\n\t'mouseover',\n\t'mouseup',\n\t'pointerdown',\n\t'pointermove',\n\t'pointerout',\n\t'pointerover',\n\t'pointerup',\n\t'touchend',\n\t'touchmove',\n\t'touchstart'\n];\n\n/** List of Element events that will be delegated and are passive */\nexport const PassiveDelegatedEvents = ['touchstart', 'touchmove', 'touchend'];\n\n/**\n * @type {Record<string, string>}\n * List of attribute names that should be aliased to their property names\n * because they behave differently between setting them as an attribute and\n * setting them as a property.\n */\nexport const AttributeAliases = {\n\t// no `class: 'className'` because we handle that separately\n\tformnovalidate: 'formNoValidate',\n\tismap: 'isMap',\n\tnomodule: 'noModule',\n\tplaysinline: 'playsInline',\n\treadonly: 'readOnly'\n};\n\n/**\n * Attributes that are boolean, i.e. they are present or not present.\n */\nexport const DOMBooleanAttributes = [\n\t'allowfullscreen',\n\t'async',\n\t'autofocus',\n\t'autoplay',\n\t'checked',\n\t'controls',\n\t'default',\n\t'disabled',\n\t'formnovalidate',\n\t'hidden',\n\t'indeterminate',\n\t'ismap',\n\t'loop',\n\t'multiple',\n\t'muted',\n\t'nomodule',\n\t'novalidate',\n\t'open',\n\t'playsinline',\n\t'readonly',\n\t'required',\n\t'reversed',\n\t'seamless',\n\t'selected'\n];\n\nexport const namespace_svg = 'http://www.w3.org/2000/svg';\nexport const namespace_html = 'http://www.w3.org/1999/xhtml';\n\n// while `input` is also an interactive element, it is never moved by the browser, so we don't need to check for it\nexport const interactive_elements = new Set([\n\t'a',\n\t'button',\n\t'iframe',\n\t'embed',\n\t'select',\n\t'textarea'\n]);\n\nexport const disallowed_parapgraph_contents = [\n\t'address',\n\t'article',\n\t'aside',\n\t'blockquote',\n\t'details',\n\t'div',\n\t'dl',\n\t'fieldset',\n\t'figcapture',\n\t'figure',\n\t'footer',\n\t'form',\n\t'h1',\n\t'h2',\n\t'h3',\n\t'h4',\n\t'h5',\n\t'h6',\n\t'header',\n\t'hr',\n\t'menu',\n\t'nav',\n\t'ol',\n\t'pre',\n\t'section',\n\t'table',\n\t'ul'\n];\n\n// https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags\nconst implied_end_tags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];\n\n/**\n * @param {string} tag\n * @param {string} parent_tag\n * @returns {boolean}\n */\nexport function is_tag_valid_with_parent(tag, parent_tag) {\n\t// First, let's check if we're in an unusual parsing mode...\n\tswitch (parent_tag) {\n\t\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect\n\t\tcase 'select':\n\t\t\treturn tag === 'option' || tag === 'optgroup' || tag === '#text';\n\t\tcase 'optgroup':\n\t\t\treturn tag === 'option' || tag === '#text';\n\t\t// Strictly speaking, seeing an <option> doesn't mean we're in a <select>\n\t\t// but\n\t\tcase 'option':\n\t\t\treturn tag === '#text';\n\t\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd\n\t\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption\n\t\t// No special behavior since these rules fall back to \"in body\" mode for\n\t\t// all except special table nodes which cause bad parsing behavior anyway.\n\n\t\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr\n\t\tcase 'tr':\n\t\t\treturn (\n\t\t\t\ttag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template'\n\t\t\t);\n\t\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody\n\t\tcase 'tbody':\n\t\tcase 'thead':\n\t\tcase 'tfoot':\n\t\t\treturn tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';\n\t\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup\n\t\tcase 'colgroup':\n\t\t\treturn tag === 'col' || tag === 'template';\n\t\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable\n\t\tcase 'table':\n\t\t\treturn (\n\t\t\t\ttag === 'caption' ||\n\t\t\t\ttag === 'colgroup' ||\n\t\t\t\ttag === 'tbody' ||\n\t\t\t\ttag === 'tfoot' ||\n\t\t\t\ttag === 'thead' ||\n\t\t\t\ttag === 'style' ||\n\t\t\t\ttag === 'script' ||\n\t\t\t\ttag === 'template'\n\t\t\t);\n\t\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead\n\t\tcase 'head':\n\t\t\treturn (\n\t\t\t\ttag === 'base' ||\n\t\t\t\ttag === 'basefont' ||\n\t\t\t\ttag === 'bgsound' ||\n\t\t\t\ttag === 'link' ||\n\t\t\t\ttag === 'meta' ||\n\t\t\t\ttag === 'title' ||\n\t\t\t\ttag === 'noscript' ||\n\t\t\t\ttag === 'noframes' ||\n\t\t\t\ttag === 'style' ||\n\t\t\t\ttag === 'script' ||\n\t\t\t\ttag === 'template'\n\t\t\t);\n\t\t// https://html.spec.whatwg.org/multipage/semantics.html#the-html-element\n\t\tcase 'html':\n\t\t\treturn tag === 'head' || tag === 'body' || tag === 'frameset';\n\t\tcase 'frameset':\n\t\t\treturn tag === 'frame';\n\t\tcase '#document':\n\t\t\treturn tag === 'html';\n\t}\n\n\t// Probably in the \"in body\" parsing mode, so we outlaw only tag combos\n\t// where the parsing rules cause implicit opens or closes to be added.\n\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\n\tswitch (tag) {\n\t\tcase 'h1':\n\t\tcase 'h2':\n\t\tcase 'h3':\n\t\tcase 'h4':\n\t\tcase 'h5':\n\t\tcase 'h6':\n\t\t\treturn (\n\t\t\t\tparent_tag !== 'h1' &&\n\t\t\t\tparent_tag !== 'h2' &&\n\t\t\t\tparent_tag !== 'h3' &&\n\t\t\t\tparent_tag !== 'h4' &&\n\t\t\t\tparent_tag !== 'h5' &&\n\t\t\t\tparent_tag !== 'h6'\n\t\t\t);\n\n\t\tcase 'rp':\n\t\tcase 'rt':\n\t\t\treturn implied_end_tags.indexOf(parent_tag) === -1;\n\n\t\tcase 'body':\n\t\tcase 'caption':\n\t\tcase 'col':\n\t\tcase 'colgroup':\n\t\tcase 'frameset':\n\t\tcase 'frame':\n\t\tcase 'head':\n\t\tcase 'html':\n\t\tcase 'tbody':\n\t\tcase 'td':\n\t\tcase 'tfoot':\n\t\tcase 'th':\n\t\tcase 'thead':\n\t\tcase 'tr':\n\t\t\t// These tags are only valid with a few parents that have special child\n\t\t\t// parsing rules -- if we're down here, then none of those matched and\n\t\t\t// so we allow it only if we don't know what the parent is, as all other\n\t\t\t// cases are invalid.\n\t\t\treturn parent_tag == null;\n\t}\n\n\treturn true;\n}\n", "import { untrack } from './runtime.js';\nimport { is_array } from './utils.js';\n\n/** regex of all html void element names */\nconst void_element_names =\n\t/^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;\n\n/** @param {string} tag */\nfunction is_void(tag) {\n\treturn void_element_names.test(tag) || tag.toLowerCase() === '!doctype';\n}\n\n/**\n * @param {any} store\n * @param {string} name\n */\nexport function validate_store(store, name) {\n\tif (store != null && typeof store.subscribe !== 'function') {\n\t\tthrow new Error(`'${name}' is not a store with a 'subscribe' method`);\n\t}\n}\n\n/**\n * @param {() => any} component_fn\n * @returns {any}\n */\nexport function validate_dynamic_component(component_fn) {\n\tconst error_message = 'this={...} of <svelte:component> should specify a Svelte component.';\n\ttry {\n\t\tconst instance = component_fn();\n\t\tif (instance !== undefined && typeof instance !== 'object') {\n\t\t\tthrow new Error(error_message);\n\t\t}\n\t\treturn instance;\n\t} catch (err) {\n\t\tconst { message } = /** @type {Error} */ (err);\n\t\tif (typeof message === 'string' && message.indexOf('is not a function') !== -1) {\n\t\t\tthrow new Error(error_message);\n\t\t} else {\n\t\t\tthrow err;\n\t\t}\n\t}\n}\n\n/**\n * @param {() => string} tag_fn\n * @returns {void}\n */\nexport function validate_void_dynamic_element(tag_fn) {\n\tconst tag = tag_fn();\n\tif (tag && is_void(tag)) {\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.warn(`<svelte:element this=\"${tag}\"> is self-closing and cannot have content.`);\n\t}\n}\n\n/** @param {() => unknown} tag_fn */\nexport function validate_dynamic_element_tag(tag_fn) {\n\tconst tag = tag_fn();\n\tconst is_string = typeof tag === 'string';\n\tif (tag && !is_string) {\n\t\tthrow new Error('<svelte:element> expects \"this\" attribute to be a string.');\n\t}\n}\n\n/**\n * @param {() => any} collection\n * @param {(item: any, index: number) => string} key_fn\n * @returns {void}\n */\nexport function validate_each_keys(collection, key_fn) {\n\tconst keys = new Map();\n\tconst maybe_array = untrack(() => collection());\n\tconst array = is_array(maybe_array)\n\t\t? maybe_array\n\t\t: maybe_array == null\n\t\t\t? []\n\t\t\t: Array.from(maybe_array);\n\tconst length = array.length;\n\tfor (let i = 0; i < length; i++) {\n\t\tconst key = key_fn(array[i], i);\n\t\tif (keys.has(key)) {\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot have duplicate keys in a keyed each: Keys at index ${keys.get(\n\t\t\t\t\tkey\n\t\t\t\t)} and ${i} with value '${array[i]}' are duplicates`\n\t\t\t);\n\t\t}\n\t\tkeys.set(key, i);\n\t}\n}\n\n/**\n * @param {number} timeout\n * @returns {() => void}\n * */\nexport function loop_guard(timeout) {\n\tconst start = Date.now();\n\treturn () => {\n\t\tif (Date.now() - start > timeout) {\n\t\t\tthrow new Error('Infinite loop detected');\n\t\t}\n\t};\n}\n\nconst snippet_symbol = Symbol.for('svelte.snippet');\n\n/**\n * @param {any} fn\n */\nexport function add_snippet_symbol(fn) {\n\tfn[snippet_symbol] = true;\n\treturn fn;\n}\n\n/**\n * Validate that the function handed to `{@render ...}` is a snippet function, and not some other kind of function.\n * @param {any} snippet_fn\n */\nexport function validate_snippet(snippet_fn) {\n\tif (snippet_fn && snippet_fn[snippet_symbol] !== true) {\n\t\tthrow new Error(\n\t\t\t'The argument to `{@render ...}` must be a snippet function, not a component or some other kind of function. ' +\n\t\t\t\t'If you want to dynamically render one snippet or another, use `$derived` and pass its result to `{@render ...}`.'\n\t\t);\n\t}\n\treturn snippet_fn;\n}\n\n/**\n * Validate that the function behind `<Component />` isn't a snippet.\n * @param {any} component_fn\n */\nexport function validate_component(component_fn) {\n\tif (component_fn?.[snippet_symbol] === true) {\n\t\tthrow new Error('A snippet must be rendered with `{@render ...}`');\n\t}\n\treturn component_fn;\n}\n"],
  "mappings": "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",
  "names": ["proxy", "is_array", "s", "current_block", "effect", "source", "get", "inspect", "value", "unwrap", "effect"]
}
