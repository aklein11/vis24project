import {
  DEV
} from "./chunk-IP2U24VQ.js";
import {
  run_all
} from "./chunk-LQRLXBZM.js";

// node_modules/svelte/src/internal/client/utils.js
var is_array = Array.isArray;
var array_from = Array.from;
var object_assign = Object.assign;
var is_frozen = Object.isFrozen;
var object_freeze = Object.freeze;
var define_property = Object.defineProperty;
var get_descriptor = Object.getOwnPropertyDescriptor;
var get_descriptors = Object.getOwnPropertyDescriptors;
var object_prototype = Object.prototype;
var array_prototype = Array.prototype;
var get_prototype_of = Object.getPrototypeOf;
function is_function(thing) {
  return typeof thing === "function";
}

// node_modules/svelte/src/internal/client/reactivity/equality.js
function default_equals(a, b) {
  return a === b;
}
function safe_not_equal(a, b) {
  return a != a ? (
    // eslint-disable-next-line eqeqeq
    b == b
  ) : a !== b || a !== null && typeof a === "object" || typeof a === "function";
}
function safe_equal(a, b) {
  return !safe_not_equal(a, b);
}

// node_modules/svelte/src/internal/client/constants.js
var SOURCE = 1;
var DERIVED = 1 << 1;
var EFFECT = 1 << 2;
var PRE_EFFECT = 1 << 3;
var RENDER_EFFECT = 1 << 4;
var MANAGED = 1 << 6;
var UNOWNED = 1 << 7;
var CLEAN = 1 << 8;
var DIRTY = 1 << 9;
var MAYBE_DIRTY = 1 << 10;
var INERT = 1 << 11;
var DESTROYED = 1 << 12;
var ROOT_BLOCK = 0;
var IF_BLOCK = 1;
var EACH_BLOCK = 2;
var EACH_ITEM_BLOCK = 3;
var AWAIT_BLOCK = 4;
var KEY_BLOCK = 5;
var HEAD_BLOCK = 6;
var DYNAMIC_COMPONENT_BLOCK = 7;
var DYNAMIC_ELEMENT_BLOCK = 8;
var SNIPPET_BLOCK = 9;
var UNINITIALIZED = Symbol();
var STATE_SYMBOL = Symbol("$state");

// node_modules/svelte/src/internal/client/dev/ownership.js
var boundaries = {};
var chrome_pattern = /at (?:.+ \()?(.+):(\d+):(\d+)\)?$/;
var firefox_pattern = /@(.+):(\d+):(\d+)$/;
function get_stack() {
  const stack = new Error().stack;
  if (!stack)
    return null;
  const entries = [];
  for (const line of stack.split("\n")) {
    let match = chrome_pattern.exec(line) ?? firefox_pattern.exec(line);
    if (match) {
      entries.push({
        file: match[1],
        line: +match[2],
        column: +match[3]
      });
    }
  }
  return entries;
}
function get_component() {
  var _a;
  const stack = (_a = get_stack()) == null ? void 0 : _a.slice(4);
  if (!stack)
    return null;
  for (let i = 0; i < stack.length; i++) {
    const entry = stack[i];
    const modules = boundaries[entry.file];
    if (!modules) {
      if (i === 0)
        return null;
      continue;
    }
    for (const module of modules) {
      if (module.start.line < entry.line && module.end.line > entry.line) {
        return module.component;
      }
    }
  }
  return null;
}
function mark_module_start(component) {
  var _a, _b;
  const start = (_a = get_stack()) == null ? void 0 : _a[2];
  if (start) {
    (boundaries[_b = start.file] ?? (boundaries[_b] = [])).push({
      start,
      // @ts-expect-error
      end: null,
      component
    });
  }
}
function mark_module_end() {
  var _a;
  const end = (_a = get_stack()) == null ? void 0 : _a[2];
  if (end) {
    const boundaries_file = boundaries[end.file];
    boundaries_file[boundaries_file.length - 1].end = end;
  }
}
function add_owner(object, owner) {
  untrack(() => {
    add_owner_to_object(object, owner);
  });
}
function add_owner_to_object(object, owner) {
  var _a;
  if (((_a = object == null ? void 0 : object[STATE_SYMBOL]) == null ? void 0 : _a.o) && !object[STATE_SYMBOL].o.has(owner)) {
    object[STATE_SYMBOL].o.add(owner);
    for (const key in object) {
      add_owner_to_object(object[key], owner);
    }
  }
}
function strip_owner(object) {
  untrack(() => {
    strip_owner_from_object(object);
  });
}
function strip_owner_from_object(object) {
  var _a;
  if ((_a = object == null ? void 0 : object[STATE_SYMBOL]) == null ? void 0 : _a.o) {
    object[STATE_SYMBOL].o = null;
    for (const key in object) {
      strip_owner(object[key]);
    }
  }
}
function check_ownership(owners) {
  const component = get_component();
  if (component && !owners.has(component)) {
    let original = [...owners][0];
    let message = (
      // @ts-expect-error
      original.filename !== component.filename ? (
        // @ts-expect-error
        `${component.filename} mutated a value owned by ${original.filename}. This is strongly discouraged`
      ) : "Mutating a value outside the component that created it is strongly discouraged"
    );
    console.warn(
      `${message}. Consider passing values to child components with \`bind:\`, or use a callback instead.`
    );
    console.trace();
  }
}

// node_modules/svelte/src/internal/client/reactivity/sources.js
function source(initial_value) {
  return create_source_signal(SOURCE | CLEAN, initial_value);
}
function mutable_source(initial_value) {
  var _a;
  const s = source(initial_value);
  s.e = safe_equal;
  if (current_component_context) {
    ((_a = current_component_context).d ?? (_a.d = [])).push(s);
  }
  return s;
}
function create_source_signal(flags, value) {
  if (DEV) {
    return {
      // consumers
      c: null,
      // equals
      e: default_equals,
      // flags
      f: flags,
      // value
      v: value,
      // write version
      w: 0,
      // this is for DEV only
      inspect: /* @__PURE__ */ new Set()
    };
  }
  return {
    // consumers
    c: null,
    // equals
    e: default_equals,
    // flags
    f: flags,
    // value
    v: value,
    // write version
    w: 0
  };
}

// node_modules/svelte/src/internal/client/proxy.js
function proxy(value, immutable = true, owners) {
  if (typeof value === "object" && value != null && !is_frozen(value)) {
    if (STATE_SYMBOL in value) {
      const metadata = (
        /** @type {import('./types.js').ProxyMetadata<T>} */
        value[STATE_SYMBOL]
      );
      if (metadata.t === value || metadata.p === value) {
        if (DEV) {
          if (owners) {
            for (const owner of owners) {
              add_owner(value, owner);
            }
          } else {
            strip_owner(value);
          }
        }
        return metadata.p;
      }
    }
    const prototype = get_prototype_of(value);
    if (prototype === object_prototype || prototype === array_prototype) {
      const proxy2 = new Proxy(value, state_proxy_handler);
      define_property(value, STATE_SYMBOL, {
        value: (
          /** @type {import('./types.js').ProxyMetadata} */
          {
            s: /* @__PURE__ */ new Map(),
            v: source(0),
            a: is_array(value),
            i: immutable,
            p: proxy2,
            t: value
          }
        ),
        writable: true,
        enumerable: false
      });
      if (DEV) {
        value[STATE_SYMBOL].o = owners === void 0 ? current_component_context ? (
          // @ts-expect-error
          /* @__PURE__ */ new Set([current_component_context.function])
        ) : null : owners && new Set(owners);
      }
      return proxy2;
    }
  }
  return value;
}
function unwrap(value, already_unwrapped) {
  if (typeof value === "object" && value != null && STATE_SYMBOL in value) {
    const unwrapped = already_unwrapped.get(value);
    if (unwrapped !== void 0) {
      return unwrapped;
    }
    if (is_array(value)) {
      const array = [];
      already_unwrapped.set(value, array);
      for (const element of value) {
        array.push(unwrap(element, already_unwrapped));
      }
      return array;
    } else {
      const obj = {};
      const keys = Reflect.ownKeys(value);
      const descriptors = get_descriptors(value);
      already_unwrapped.set(value, obj);
      for (const key of keys) {
        if (key === STATE_SYMBOL)
          continue;
        if (descriptors[key].get) {
          define_property(obj, key, descriptors[key]);
        } else {
          const property = value[key];
          obj[key] = unwrap(property, already_unwrapped);
        }
      }
      return obj;
    }
  }
  return value;
}
function unstate(value) {
  return (
    /** @type {T} */
    unwrap(
      /** @type {import('./types.js').ProxyStateObject} */
      value,
      /* @__PURE__ */ new Map()
    )
  );
}
function update_version(signal, d = 1) {
  const value = untrack(() => get(signal));
  set_signal_value(signal, value + d);
}
var state_proxy_handler = {
  defineProperty(target, prop, descriptor) {
    if (descriptor.value) {
      const metadata = target[STATE_SYMBOL];
      const s = metadata.s.get(prop);
      if (s !== void 0)
        set(s, proxy(descriptor.value, metadata.i, metadata.o));
    }
    return Reflect.defineProperty(target, prop, descriptor);
  },
  deleteProperty(target, prop) {
    const metadata = target[STATE_SYMBOL];
    const s = metadata.s.get(prop);
    const is_array2 = metadata.a;
    const boolean = delete target[prop];
    if (is_array2 && boolean) {
      const ls = metadata.s.get("length");
      const length = target.length - 1;
      if (ls !== void 0 && ls.v !== length) {
        set(ls, length);
      }
    }
    if (s !== void 0)
      set(s, UNINITIALIZED);
    if (boolean) {
      update_version(metadata.v);
    }
    return boolean;
  },
  get(target, prop, receiver) {
    var _a;
    if (prop === STATE_SYMBOL) {
      return Reflect.get(target, STATE_SYMBOL);
    }
    const metadata = target[STATE_SYMBOL];
    let s = metadata.s.get(prop);
    if (s === void 0 && (effect_active() || updating_derived) && (!(prop in target) || ((_a = get_descriptor(target, prop)) == null ? void 0 : _a.writable))) {
      s = (metadata.i ? source : mutable_source)(proxy(target[prop], metadata.i, metadata.o));
      metadata.s.set(prop, s);
    }
    if (s !== void 0) {
      const value = get(s);
      return value === UNINITIALIZED ? void 0 : value;
    }
    if (DEV) {
      if (typeof target[prop] === "function" && prop !== Symbol.iterator) {
        return batch_inspect(target, prop, receiver);
      }
    }
    return Reflect.get(target, prop, receiver);
  },
  getOwnPropertyDescriptor(target, prop) {
    const descriptor = Reflect.getOwnPropertyDescriptor(target, prop);
    if (descriptor && "value" in descriptor) {
      const metadata = target[STATE_SYMBOL];
      const s = metadata.s.get(prop);
      if (s) {
        descriptor.value = get(s);
      }
    }
    return descriptor;
  },
  has(target, prop) {
    var _a;
    if (prop === STATE_SYMBOL) {
      return true;
    }
    const metadata = target[STATE_SYMBOL];
    const has = Reflect.has(target, prop);
    let s = metadata.s.get(prop);
    if (s !== void 0 || effect_active() && (!has || ((_a = get_descriptor(target, prop)) == null ? void 0 : _a.writable))) {
      if (s === void 0) {
        s = (metadata.i ? source : mutable_source)(
          has ? proxy(target[prop], metadata.i, metadata.o) : UNINITIALIZED
        );
        metadata.s.set(prop, s);
      }
      const value = get(s);
      if (value === UNINITIALIZED) {
        return false;
      }
    }
    return has;
  },
  set(target, prop, value, receiver) {
    const metadata = target[STATE_SYMBOL];
    let s = metadata.s.get(prop);
    if (s === void 0 && effect_active()) {
      untrack(() => receiver[prop]);
      s = metadata.s.get(prop);
    }
    if (s !== void 0) {
      set(s, proxy(value, metadata.i, metadata.o));
    }
    const is_array2 = metadata.a;
    const not_has = !(prop in target);
    if (DEV) {
      if (metadata.o) {
        check_ownership(metadata.o);
        for (const owner in metadata.o) {
          add_owner(value, owner);
        }
      } else {
        strip_owner(value);
      }
    }
    if (is_array2 && prop === "length") {
      for (let i = value; i < target.length; i += 1) {
        const s2 = metadata.s.get(i + "");
        if (s2 !== void 0)
          set(s2, UNINITIALIZED);
      }
    }
    target[prop] = value;
    if (not_has) {
      if (is_array2) {
        const ls = metadata.s.get("length");
        const length = target.length;
        if (ls !== void 0 && ls.v !== length) {
          set(ls, length);
        }
      }
      update_version(metadata.v);
    }
    return true;
  },
  ownKeys(target) {
    const metadata = target[STATE_SYMBOL];
    get(metadata.v);
    return Reflect.ownKeys(target);
  }
};
if (DEV) {
  state_proxy_handler.setPrototypeOf = () => {
    throw new Error("Cannot set prototype of $state object");
  };
}

// node_modules/svelte/src/internal/client/dom/task.js
var is_task_queued = false;
var is_raf_queued = false;
var current_queued_tasks = [];
var current_raf_tasks = [];
function process_task() {
  is_task_queued = false;
  const tasks = current_queued_tasks.slice();
  current_queued_tasks = [];
  run_all(tasks);
}
function process_raf_task() {
  is_raf_queued = false;
  const tasks = current_raf_tasks.slice();
  current_raf_tasks = [];
  run_all(tasks);
}
function schedule_task(fn) {
  if (!is_task_queued) {
    is_task_queued = true;
    setTimeout(process_task, 0);
  }
  current_queued_tasks.push(fn);
}
function schedule_raf_task(fn) {
  if (!is_raf_queued) {
    is_raf_queued = true;
    requestAnimationFrame(process_raf_task);
  }
  current_raf_tasks.push(fn);
}
function flush_tasks() {
  if (is_task_queued) {
    process_task();
  }
  if (is_raf_queued) {
    process_raf_task();
  }
}

// node_modules/svelte/src/internal/client/runtime.js
var IS_EFFECT = EFFECT | PRE_EFFECT | RENDER_EFFECT;
var FLUSH_MICROTASK = 0;
var FLUSH_SYNC = 1;
var current_scheduler_mode = FLUSH_MICROTASK;
var is_micro_task_queued = false;
var is_flushing_effect = false;
var is_batching_effect = false;
var is_inspecting_signal = false;
var current_queued_pre_and_render_effects = [];
var current_queued_effects = [];
var flush_count = 0;
var current_consumer = null;
var current_effect = null;
var current_dependencies = null;
var current_dependencies_index = 0;
var current_untracked_writes = null;
var last_inspected_signal = null;
var current_untracking = false;
var ignore_mutation_validation = false;
function set_ignore_mutation_validation(value) {
  ignore_mutation_validation = value;
}
var current_skip_consumer = false;
var is_signals_recorded = false;
var captured_signals = /* @__PURE__ */ new Set();
var inspect_fn = null;
var inspect_captured_signals = [];
var current_block = null;
var current_component_context = null;
var updating_derived = false;
function is_runes(context) {
  const component_context = context || current_component_context;
  return component_context !== null && component_context.r;
}
function batch_inspect(target, prop, receiver) {
  const value = Reflect.get(target, prop, receiver);
  return function() {
    const previously_batching_effect = is_batching_effect;
    is_batching_effect = true;
    try {
      return Reflect.apply(value, this, arguments);
    } finally {
      is_batching_effect = previously_batching_effect;
      if (last_inspected_signal !== null && !is_inspecting_signal) {
        is_inspecting_signal = true;
        try {
          for (const fn of last_inspected_signal.inspect) {
            fn();
          }
        } finally {
          is_inspecting_signal = false;
        }
        last_inspected_signal = null;
      }
    }
  };
}
function is_signal_dirty(signal) {
  const flags = signal.f;
  if ((flags & DIRTY) !== 0 || signal.v === UNINITIALIZED) {
    return true;
  }
  if ((flags & MAYBE_DIRTY) !== 0) {
    const dependencies = (
      /** @type {import('./types.js').ComputationSignal<V>} **/
      signal.d
    );
    if (dependencies !== null) {
      const length = dependencies.length;
      let i;
      for (i = 0; i < length; i++) {
        const dependency = dependencies[i];
        if ((dependency.f & MAYBE_DIRTY) !== 0 && !is_signal_dirty(dependency)) {
          set_signal_status(dependency, CLEAN);
          continue;
        }
        if ((dependency.f & DIRTY) !== 0) {
          if ((dependency.f & DERIVED) !== 0) {
            update_derived(
              /** @type {import('./types.js').ComputationSignal<V>} **/
              dependency,
              true
            );
            if ((signal.f & DIRTY) !== 0) {
              return true;
            }
          } else {
            return true;
          }
        }
        const is_unowned = (flags & UNOWNED) !== 0;
        const write_version = signal.w;
        const dep_write_version = dependency.w;
        if (is_unowned && dep_write_version > write_version) {
          signal.w = dep_write_version;
          return true;
        }
      }
    }
  }
  return false;
}
function execute_signal_fn(signal) {
  const init = signal.i;
  const flags = signal.f;
  const previous_dependencies = current_dependencies;
  const previous_dependencies_index = current_dependencies_index;
  const previous_untracked_writes = current_untracked_writes;
  const previous_consumer = current_consumer;
  const previous_block = current_block;
  const previous_component_context = current_component_context;
  const previous_skip_consumer = current_skip_consumer;
  const is_render_effect = (flags & RENDER_EFFECT) !== 0;
  const previous_untracking = current_untracking;
  current_dependencies = /** @type {null | import('./types.js').Signal[]} */
  null;
  current_dependencies_index = 0;
  current_untracked_writes = null;
  current_consumer = signal;
  current_block = signal.b;
  current_component_context = signal.x;
  current_skip_consumer = !is_flushing_effect && (flags & UNOWNED) !== 0;
  current_untracking = false;
  try {
    let res;
    if (is_render_effect) {
      res = /** @type {(block: import('./types.js').Block, signal: import('./types.js').Signal) => V} */
      init(
        /** @type {import('./types.js').Block} */
        signal.b,
        /** @type {import('./types.js').Signal} */
        signal
      );
    } else {
      res = /** @type {() => V} */
      init();
    }
    let dependencies = (
      /** @type {import('./types.js').Signal<unknown>[]} **/
      signal.d
    );
    if (current_dependencies !== null) {
      let i;
      if (dependencies !== null) {
        const deps_length = dependencies.length;
        const full_current_dependencies = current_dependencies_index === 0 ? current_dependencies : dependencies.slice(0, current_dependencies_index).concat(current_dependencies);
        const current_dep_length = full_current_dependencies.length;
        const full_current_dependencies_set = current_dep_length > 16 && deps_length - current_dependencies_index > 1 ? new Set(full_current_dependencies) : null;
        for (i = current_dependencies_index; i < deps_length; i++) {
          const dependency = dependencies[i];
          if (full_current_dependencies_set !== null ? !full_current_dependencies_set.has(dependency) : !full_current_dependencies.includes(dependency)) {
            remove_consumer(signal, dependency);
          }
        }
      }
      if (dependencies !== null && current_dependencies_index > 0) {
        dependencies.length = current_dependencies_index + current_dependencies.length;
        for (i = 0; i < current_dependencies.length; i++) {
          dependencies[current_dependencies_index + i] = current_dependencies[i];
        }
      } else {
        signal.d = /** @type {import('./types.js').Signal<V>[]} **/
        dependencies = current_dependencies;
      }
      if (!current_skip_consumer) {
        for (i = current_dependencies_index; i < dependencies.length; i++) {
          const dependency = dependencies[i];
          const consumers = dependency.c;
          if (consumers === null) {
            dependency.c = [signal];
          } else if (consumers[consumers.length - 1] !== signal) {
            consumers.push(signal);
          }
        }
      }
    } else if (dependencies !== null && current_dependencies_index < dependencies.length) {
      remove_consumers(signal, current_dependencies_index);
      dependencies.length = current_dependencies_index;
    }
    return res;
  } finally {
    current_dependencies = previous_dependencies;
    current_dependencies_index = previous_dependencies_index;
    current_untracked_writes = previous_untracked_writes;
    current_consumer = previous_consumer;
    current_block = previous_block;
    current_component_context = previous_component_context;
    current_skip_consumer = previous_skip_consumer;
    current_untracking = previous_untracking;
  }
}
function remove_consumer(signal, dependency) {
  const consumers = dependency.c;
  let consumers_length = 0;
  if (consumers !== null) {
    consumers_length = consumers.length - 1;
    const index = consumers.indexOf(signal);
    if (index !== -1) {
      if (consumers_length === 0) {
        dependency.c = null;
      } else {
        consumers[index] = consumers[consumers_length];
        consumers.pop();
      }
    }
  }
  if (consumers_length === 0 && (dependency.f & UNOWNED) !== 0) {
    set_signal_status(dependency, DIRTY);
    remove_consumers(
      /** @type {import('./types.js').ComputationSignal<V>} **/
      dependency,
      0
    );
  }
}
function remove_consumers(signal, start_index) {
  const dependencies = signal.d;
  if (dependencies !== null) {
    const active_dependencies = start_index === 0 ? null : dependencies.slice(0, start_index);
    let i;
    for (i = start_index; i < dependencies.length; i++) {
      const dependency = dependencies[i];
      if (active_dependencies === null || !active_dependencies.includes(dependency)) {
        remove_consumer(signal, dependency);
      }
    }
  }
}
function destroy_references(signal) {
  const references = signal.r;
  signal.r = null;
  if (references !== null) {
    let i;
    for (i = 0; i < references.length; i++) {
      destroy_signal(references[i]);
    }
  }
}
function report_error(block, error) {
  let current_block2 = block;
  if (current_block2 !== null) {
    throw error;
  }
}
function execute_effect(signal) {
  if ((signal.f & DESTROYED) !== 0) {
    return;
  }
  const teardown = signal.v;
  const previous_effect = current_effect;
  current_effect = signal;
  try {
    destroy_references(signal);
    if (teardown !== null) {
      teardown();
    }
    const possible_teardown = execute_signal_fn(signal);
    if (typeof possible_teardown === "function") {
      signal.v = possible_teardown;
    }
  } catch (error) {
    const block = signal.b;
    if (block !== null) {
      report_error(block, error);
    } else {
      throw error;
    }
  } finally {
    current_effect = previous_effect;
  }
  const component_context = signal.x;
  if (is_runes(component_context) && // Don't rerun pre effects more than once to accomodate for "$: only runs once" behavior
  (signal.f & PRE_EFFECT) !== 0 && current_queued_pre_and_render_effects.length > 0) {
    flush_local_pre_effects(component_context);
  }
}
function infinite_loop_guard() {
  if (flush_count > 100) {
    flush_count = 0;
    throw new Error(
      "ERR_SVELTE_TOO_MANY_UPDATES" + (DEV ? ": Maximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops." : "")
    );
  }
  flush_count++;
}
function flush_queued_effects(effects) {
  const length = effects.length;
  if (length > 0) {
    infinite_loop_guard();
    const previously_flushing_effect = is_flushing_effect;
    is_flushing_effect = true;
    try {
      let i;
      for (i = 0; i < length; i++) {
        const signal = effects[i];
        const flags = signal.f;
        if ((flags & (DESTROYED | INERT)) === 0) {
          if (is_signal_dirty(signal)) {
            set_signal_status(signal, CLEAN);
            execute_effect(signal);
          } else if ((flags & MAYBE_DIRTY) !== 0) {
            set_signal_status(signal, CLEAN);
          }
        }
      }
    } finally {
      is_flushing_effect = previously_flushing_effect;
    }
    effects.length = 0;
  }
}
function process_microtask() {
  is_micro_task_queued = false;
  if (flush_count > 101) {
    return;
  }
  const previous_queued_pre_and_render_effects = current_queued_pre_and_render_effects;
  const previous_queued_effects = current_queued_effects;
  current_queued_pre_and_render_effects = [];
  current_queued_effects = [];
  flush_queued_effects(previous_queued_pre_and_render_effects);
  flush_queued_effects(previous_queued_effects);
  if (!is_micro_task_queued) {
    flush_count = 0;
  }
}
function schedule_effect(signal, sync) {
  const flags = signal.f;
  if (sync) {
    const previously_flushing_effect = is_flushing_effect;
    try {
      is_flushing_effect = true;
      execute_effect(signal);
      set_signal_status(signal, CLEAN);
    } finally {
      is_flushing_effect = previously_flushing_effect;
    }
  } else {
    if (current_scheduler_mode === FLUSH_MICROTASK) {
      if (!is_micro_task_queued) {
        is_micro_task_queued = true;
        queueMicrotask(process_microtask);
      }
    }
    if ((flags & EFFECT) !== 0) {
      current_queued_effects.push(signal);
      if ((flags & MANAGED) === 0) {
        mark_subtree_children_inert(signal, true);
      }
    } else {
      const length = current_queued_pre_and_render_effects.length;
      let should_append = length === 0;
      if (!should_append) {
        const target_level = signal.l;
        const target_block = signal.b;
        const is_pre_effect = (flags & PRE_EFFECT) !== 0;
        let target_signal;
        let is_target_pre_effect;
        let i = length;
        while (true) {
          target_signal = current_queued_pre_and_render_effects[--i];
          if (target_signal.l <= target_level) {
            if (i + 1 === length) {
              should_append = true;
            } else {
              is_target_pre_effect = (target_signal.f & PRE_EFFECT) !== 0;
              if (target_signal.b !== target_block || is_target_pre_effect && !is_pre_effect) {
                i++;
              }
              current_queued_pre_and_render_effects.splice(i, 0, signal);
            }
            break;
          }
          if (i === 0) {
            current_queued_pre_and_render_effects.unshift(signal);
            break;
          }
        }
      }
      if (should_append) {
        current_queued_pre_and_render_effects.push(signal);
      }
    }
  }
}
function flush_local_render_effects() {
  const effects = [];
  for (let i = 0; i < current_queued_pre_and_render_effects.length; i++) {
    const effect2 = current_queued_pre_and_render_effects[i];
    if ((effect2.f & RENDER_EFFECT) !== 0 && effect2.x === current_component_context) {
      effects.push(effect2);
      current_queued_pre_and_render_effects.splice(i, 1);
      i--;
    }
  }
  flush_queued_effects(effects);
}
function flush_local_pre_effects(context) {
  const effects = [];
  for (let i = 0; i < current_queued_pre_and_render_effects.length; i++) {
    const effect2 = current_queued_pre_and_render_effects[i];
    if ((effect2.f & PRE_EFFECT) !== 0 && effect2.x === context) {
      effects.push(effect2);
      current_queued_pre_and_render_effects.splice(i, 1);
      i--;
    }
  }
  flush_queued_effects(effects);
}
function flushSync(fn) {
  flush_sync(fn);
}
function flush_sync(fn, flush_previous = true) {
  const previous_scheduler_mode = current_scheduler_mode;
  const previous_queued_pre_and_render_effects = current_queued_pre_and_render_effects;
  const previous_queued_effects = current_queued_effects;
  let result;
  try {
    infinite_loop_guard();
    const pre_and_render_effects = [];
    const effects = [];
    current_scheduler_mode = FLUSH_SYNC;
    current_queued_pre_and_render_effects = pre_and_render_effects;
    current_queued_effects = effects;
    if (flush_previous) {
      flush_queued_effects(previous_queued_pre_and_render_effects);
      flush_queued_effects(previous_queued_effects);
    }
    if (fn !== void 0) {
      result = fn();
    }
    if (current_queued_pre_and_render_effects.length > 0 || effects.length > 0) {
      flushSync();
    }
    flush_tasks();
    flush_count = 0;
  } finally {
    current_scheduler_mode = previous_scheduler_mode;
    current_queued_pre_and_render_effects = previous_queued_pre_and_render_effects;
    current_queued_effects = previous_queued_effects;
  }
  return result;
}
async function tick() {
  await Promise.resolve();
  flushSync();
}
function update_derived(signal, force_schedule) {
  const previous_updating_derived = updating_derived;
  updating_derived = true;
  destroy_references(signal);
  const value = execute_signal_fn(signal);
  updating_derived = previous_updating_derived;
  const status = (current_skip_consumer || (signal.f & UNOWNED) !== 0) && signal.d !== null ? MAYBE_DIRTY : CLEAN;
  set_signal_status(signal, status);
  const equals = (
    /** @type {import('./types.js').EqualsFunctions} */
    signal.e
  );
  if (!equals(value, signal.v)) {
    signal.v = value;
    mark_signal_consumers(signal, DIRTY, force_schedule);
    if (DEV && signal.inspect && force_schedule) {
      for (
        const fn of
        /** @type {import('./types.js').SignalDebug} */
        signal.inspect
      )
        fn();
    }
  }
}
function get(signal) {
  if (DEV && signal.inspect && inspect_fn) {
    signal.inspect.add(inspect_fn);
    inspect_captured_signals.push(signal);
  }
  const flags = signal.f;
  if ((flags & DESTROYED) !== 0) {
    return signal.v;
  }
  if (is_signals_recorded) {
    captured_signals.add(signal);
  }
  if (current_consumer !== null && (current_consumer.f & MANAGED) === 0 && !current_untracking) {
    const unowned = (current_consumer.f & UNOWNED) !== 0;
    const dependencies = current_consumer.d;
    if (current_dependencies === null && dependencies !== null && dependencies[current_dependencies_index] === signal && !(unowned && current_effect !== null)) {
      current_dependencies_index++;
    } else if (dependencies === null || current_dependencies_index === 0 || dependencies[current_dependencies_index - 1] !== signal) {
      if (current_dependencies === null) {
        current_dependencies = [signal];
      } else {
        current_dependencies.push(signal);
      }
    }
    if (current_untracked_writes !== null && current_effect !== null && (current_effect.f & CLEAN) !== 0 && (current_effect.f & MANAGED) === 0 && current_untracked_writes.includes(signal)) {
      set_signal_status(current_effect, DIRTY);
      schedule_effect(current_effect, false);
    }
  }
  if ((flags & DERIVED) !== 0 && is_signal_dirty(signal)) {
    if (DEV) {
      const previous_inspect_fn = inspect_fn;
      inspect_fn = null;
      update_derived(
        /** @type {import('./types.js').ComputationSignal<V>} **/
        signal,
        false
      );
      inspect_fn = previous_inspect_fn;
    } else {
      update_derived(
        /** @type {import('./types.js').ComputationSignal<V>} **/
        signal,
        false
      );
    }
  }
  return signal.v;
}
function set(signal, value) {
  set_signal_value(signal, value);
  return value;
}
function set_sync(signal, value) {
  flushSync(() => set(signal, value));
}
function invalidate_inner_signals(fn) {
  var previous_is_signals_recorded = is_signals_recorded;
  var previous_captured_signals = captured_signals;
  is_signals_recorded = true;
  captured_signals = /* @__PURE__ */ new Set();
  var captured = captured_signals;
  var signal;
  try {
    untrack(fn);
  } finally {
    is_signals_recorded = previous_is_signals_recorded;
    if (is_signals_recorded) {
      for (signal of captured_signals) {
        previous_captured_signals.add(signal);
      }
    }
    captured_signals = previous_captured_signals;
  }
  for (signal of captured) {
    mutate(
      signal,
      null
      /* doesnt matter */
    );
  }
}
function mutate(source2, value) {
  set_signal_value(
    source2,
    untrack(() => get(source2))
  );
  return value;
}
function mark_subtree_children_inert(signal, inert, visited_blocks) {
  const references = signal.r;
  if (references !== null) {
    let i;
    for (i = 0; i < references.length; i++) {
      const reference = references[i];
      if ((reference.f & IS_EFFECT) !== 0) {
        mark_subtree_inert(reference, inert, visited_blocks);
      }
    }
  }
}
function mark_subtree_inert(signal, inert, visited_blocks = /* @__PURE__ */ new Set()) {
  const flags = signal.f;
  const is_already_inert = (flags & INERT) !== 0;
  if (is_already_inert !== inert) {
    signal.f ^= INERT;
    if (!inert && (flags & IS_EFFECT) !== 0 && (flags & CLEAN) === 0) {
      schedule_effect(
        /** @type {import('./types.js').EffectSignal} */
        signal,
        false
      );
    }
    const block = signal.b;
    if (block !== null && !visited_blocks.has(block)) {
      visited_blocks.add(block);
      const type = block.t;
      if (type === IF_BLOCK) {
        const condition_effect = block.e;
        if (condition_effect !== null && block !== current_block) {
          mark_subtree_inert(condition_effect, inert, visited_blocks);
        }
        const consequent_effect = block.ce;
        if (consequent_effect !== null && block.v) {
          mark_subtree_inert(consequent_effect, inert, visited_blocks);
        }
        const alternate_effect = block.ae;
        if (alternate_effect !== null && !block.v) {
          mark_subtree_inert(alternate_effect, inert, visited_blocks);
        }
      } else if (type === EACH_BLOCK) {
        const items = block.v;
        for (let { e: each_item_effect } of items) {
          if (each_item_effect !== null) {
            mark_subtree_inert(each_item_effect, inert, visited_blocks);
          }
        }
      }
    }
  }
  mark_subtree_children_inert(signal, inert, visited_blocks);
}
function mark_signal_consumers(signal, to_status, force_schedule) {
  const runes = is_runes(null);
  const consumers = signal.c;
  if (consumers !== null) {
    const length = consumers.length;
    let i;
    for (i = 0; i < length; i++) {
      const consumer = consumers[i];
      const flags = consumer.f;
      const unowned = (flags & UNOWNED) !== 0;
      if ((!force_schedule || !runes) && consumer === current_effect) {
        continue;
      }
      set_signal_status(consumer, to_status);
      const maybe_dirty = (flags & MAYBE_DIRTY) !== 0;
      if ((flags & CLEAN) !== 0 || maybe_dirty && unowned) {
        if ((consumer.f & IS_EFFECT) !== 0) {
          schedule_effect(
            /** @type {import('./types.js').EffectSignal} */
            consumer,
            false
          );
        } else {
          mark_signal_consumers(consumer, MAYBE_DIRTY, force_schedule);
        }
      }
    }
  }
}
function set_signal_value(signal, value) {
  if (!current_untracking && !ignore_mutation_validation && current_consumer !== null && is_runes(null) && (current_consumer.f & DERIVED) !== 0) {
    throw new Error(
      "ERR_SVELTE_UNSAFE_MUTATION" + (DEV ? `: Unsafe mutations during Svelte's render or derived phase are not permitted in runes mode. This can lead to unexpected errors and possibly cause infinite loops.

If this mutation is not meant to be reactive do not use the "$state" rune for that declaration.` : "")
    );
  }
  if ((signal.f & SOURCE) !== 0 && !/** @type {import('./types.js').EqualsFunctions} */
  signal.e(value, signal.v)) {
    signal.v = value;
    signal.w++;
    if (is_runes(null) && !ignore_mutation_validation && current_effect !== null && current_effect.c === null && (current_effect.f & CLEAN) !== 0 && (current_effect.f & MANAGED) === 0) {
      if (current_dependencies !== null && current_dependencies.includes(signal)) {
        set_signal_status(current_effect, DIRTY);
        schedule_effect(current_effect, false);
      } else {
        if (current_untracked_writes === null) {
          current_untracked_writes = [signal];
        } else {
          current_untracked_writes.push(signal);
        }
      }
    }
    mark_signal_consumers(signal, DIRTY, true);
    if (DEV && signal.inspect) {
      if (is_batching_effect) {
        last_inspected_signal = /** @type {import('./types.js').SignalDebug} */
        signal;
      } else {
        for (
          const fn of
          /** @type {import('./types.js').SignalDebug} */
          signal.inspect
        )
          fn();
      }
    }
  }
}
function destroy_signal(signal) {
  const teardown = (
    /** @type {null | (() => void)} */
    signal.v
  );
  const destroy = signal.y;
  const flags = signal.f;
  destroy_references(signal);
  remove_consumers(signal, 0);
  signal.i = signal.r = signal.y = signal.x = signal.b = signal.d = signal.c = null;
  set_signal_status(signal, DESTROYED);
  if (destroy !== null) {
    if (is_array(destroy)) {
      run_all(destroy);
    } else {
      destroy();
    }
  }
  if (teardown !== null && (flags & IS_EFFECT) !== 0) {
    teardown();
  }
}
function untrack(fn) {
  const previous_untracking = current_untracking;
  try {
    current_untracking = true;
    return fn();
  } finally {
    current_untracking = previous_untracking;
  }
}
function push_destroy_fn(signal, destroy_fn) {
  let destroy = signal.y;
  if (destroy === null) {
    signal.y = destroy_fn;
  } else if (is_array(destroy)) {
    destroy.push(destroy_fn);
  } else {
    signal.y = [destroy, destroy_fn];
  }
}
var STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);
function set_signal_status(signal, status) {
  signal.f = signal.f & STATUS_MASK | status;
}
function is_signal(val) {
  return typeof val === "object" && val !== null && typeof /** @type {import('./types.js').Signal<V>} */
  val.f === "number";
}
function getContext(key) {
  const context_map = get_or_init_context_map();
  const result = (
    /** @type {T} */
    context_map.get(key)
  );
  if (DEV) {
    const fn = current_component_context == null ? void 0 : current_component_context.function;
    if (fn) {
      add_owner(result, fn);
    }
  }
  return result;
}
function setContext(key, context) {
  const context_map = get_or_init_context_map();
  context_map.set(key, context);
  return context;
}
function hasContext(key) {
  const context_map = get_or_init_context_map();
  return context_map.has(key);
}
function getAllContexts() {
  const context_map = get_or_init_context_map();
  if (DEV) {
    const fn = current_component_context == null ? void 0 : current_component_context.function;
    if (fn) {
      for (const value of context_map.values()) {
        add_owner(value, fn);
      }
    }
  }
  return (
    /** @type {T} */
    context_map
  );
}
function get_or_init_context_map() {
  const component_context = current_component_context;
  if (component_context === null) {
    throw new Error(
      "ERR_SVELTE_ORPHAN_CONTEXT" + (DEV ? "Context can only be used during component initialisation." : "")
    );
  }
  return component_context.c ?? (component_context.c = new Map(get_parent_context(component_context) || void 0));
}
function get_parent_context(component_context) {
  let parent = component_context.p;
  while (parent !== null) {
    const context_map = parent.c;
    if (context_map !== null) {
      return context_map;
    }
    parent = parent.p;
  }
  return null;
}
function update(signal, d = 1) {
  const value = get(signal);
  set_signal_value(signal, value + d);
  return value;
}
function update_prop(fn, d = 1) {
  const value = fn();
  fn(value + d);
  return value;
}
function update_pre(signal, d = 1) {
  const value = get(signal) + d;
  set_signal_value(signal, value);
  return value;
}
function update_pre_prop(fn, d = 1) {
  const value = fn() + d;
  fn(value);
  return value;
}
function exclude_from_object(obj, keys) {
  obj = { ...obj };
  let key;
  for (key of keys) {
    delete obj[key];
  }
  return obj;
}
function value_or_fallback(value, fallback) {
  return value === void 0 ? fallback : value;
}
function push(props, runes = false, fn) {
  current_component_context = {
    // exports (and props, if `accessors: true`)
    x: null,
    // context
    c: null,
    // effects
    e: null,
    // mounted
    m: false,
    // parent
    p: current_component_context,
    // signals
    d: null,
    // props
    s: props,
    // runes
    r: runes,
    // update_callbacks
    u: null
  };
  if (DEV) {
    current_component_context.function = fn;
  }
}
function pop(component) {
  const context_stack_item = current_component_context;
  if (context_stack_item !== null) {
    if (component !== void 0) {
      context_stack_item.x = component;
    }
    const effects = context_stack_item.e;
    if (effects !== null) {
      context_stack_item.e = null;
      for (let i = 0; i < effects.length; i++) {
        schedule_effect(effects[i], false);
      }
    }
    current_component_context = context_stack_item.p;
    context_stack_item.m = true;
  }
  return component || /** @type {T} */
  {};
}
function deep_read_state(value) {
  if (typeof value !== "object" || !value || value instanceof EventTarget) {
    return;
  }
  if (STATE_SYMBOL in value) {
    deep_read(value);
  } else if (!Array.isArray(value)) {
    for (let key in value) {
      const prop = value[key];
      if (typeof prop === "object" && prop && STATE_SYMBOL in prop) {
        deep_read(prop);
      }
    }
  }
}
function deep_read(value, visited = /* @__PURE__ */ new Set()) {
  if (typeof value === "object" && value !== null && // We don't want to traverse DOM elements
  !(value instanceof EventTarget) && !visited.has(value)) {
    visited.add(value);
    for (let key in value) {
      try {
        deep_read(value[key], visited);
      } catch (e) {
      }
    }
    const proto = Object.getPrototypeOf(value);
    if (proto !== Object.prototype && proto !== Array.prototype && proto !== Map.prototype && proto !== Set.prototype && proto !== Date.prototype) {
      const descriptors = get_descriptors(proto);
      for (let key in descriptors) {
        const get2 = descriptors[key].get;
        if (get2) {
          try {
            get2.call(value);
          } catch (e) {
          }
        }
      }
    }
  }
}
function deep_unstate(value, visited = /* @__PURE__ */ new Map()) {
  if (typeof value === "object" && value !== null && !visited.has(value)) {
    const unstated = unstate(value);
    if (unstated !== value) {
      visited.set(value, unstated);
      return unstated;
    }
    const prototype = get_prototype_of(value);
    if (prototype === object_prototype || prototype === array_prototype) {
      let contains_unstated = false;
      const nested_unstated = Array.isArray(value) ? [] : {};
      for (let key in value) {
        const result = deep_unstate(value[key], visited);
        nested_unstated[key] = result;
        if (result !== value[key]) {
          contains_unstated = true;
        }
      }
      visited.set(value, contains_unstated ? nested_unstated : value);
    } else {
      visited.set(value, value);
    }
  }
  return visited.get(value) ?? value;
}
var warned_inspect_changed = false;
function inspect(get_value, inspect2 = console.log) {
  let initial = true;
  pre_effect(() => {
    const fn = () => {
      const value2 = untrack(() => get_value().map((v) => deep_unstate(v)));
      if (value2.length === 2 && typeof value2[1] === "function" && !warned_inspect_changed) {
        console.warn(
          "$inspect() API has changed. See https://svelte-5-preview.vercel.app/docs/runes#$inspect for more information."
        );
        warned_inspect_changed = true;
      }
      inspect2(initial ? "init" : "update", ...value2);
    };
    inspect_fn = fn;
    const value = get_value();
    deep_read(value);
    inspect_fn = null;
    const signals = inspect_captured_signals.slice();
    inspect_captured_signals = [];
    if (initial) {
      fn();
      initial = false;
    }
    return () => {
      for (const s of signals) {
        s.inspect.delete(fn);
      }
    };
  });
}
function unwrap2(value) {
  if (is_signal(value)) {
    return get(value);
  }
  return value;
}
if (DEV) {
  let throw_rune_error = function(rune) {
    if (!(rune in globalThis)) {
      globalThis[rune] = () => {
        throw new Error(`${rune} is only available inside .svelte and .svelte.js/ts files`);
      };
    }
  };
  throw_rune_error("$state");
  throw_rune_error("$effect");
  throw_rune_error("$derived");
  throw_rune_error("$inspect");
  throw_rune_error("$props");
}
function freeze(value) {
  if (typeof value === "object" && value != null && !is_frozen(value)) {
    if (STATE_SYMBOL in value) {
      return object_freeze(unstate(value));
    }
    object_freeze(value);
  }
  return value;
}

// node_modules/svelte/src/internal/client/reactivity/computations.js
function create_computation_signal(flags, value, block) {
  const signal = {
    b: block,
    c: null,
    d: null,
    e: null,
    f: flags,
    l: 0,
    i: null,
    r: null,
    v: value,
    w: 0,
    x: null,
    y: null
  };
  if (DEV) {
    signal.inspect = /* @__PURE__ */ new Set();
  }
  return signal;
}
function push_reference(target_signal, ref_signal) {
  const references = target_signal.r;
  if (references === null) {
    target_signal.r = [ref_signal];
  } else {
    references.push(ref_signal);
  }
}
function internal_create_effect(type, fn, sync, block, schedule) {
  const signal = create_computation_signal(type | DIRTY, null, block);
  signal.i = fn;
  signal.x = current_component_context;
  if (current_effect !== null) {
    signal.l = current_effect.l + 1;
    if ((type & MANAGED) === 0) {
      push_reference(current_effect, signal);
    }
  }
  if (schedule) {
    schedule_effect(signal, sync);
  }
  return signal;
}
function effect_active() {
  return current_effect ? (current_effect.f & MANAGED) === 0 : false;
}
function user_effect(fn) {
  if (current_effect === null) {
    throw new Error(
      "ERR_SVELTE_ORPHAN_EFFECT" + (DEV ? ": The Svelte $effect rune can only be used during component initialisation." : "")
    );
  }
  const apply_component_effect_heuristics = current_effect.f & RENDER_EFFECT && current_component_context !== null && !current_component_context.m;
  const effect2 = internal_create_effect(
    EFFECT,
    fn,
    false,
    current_block,
    !apply_component_effect_heuristics
  );
  if (apply_component_effect_heuristics) {
    const context = (
      /** @type {import('../types.js').ComponentContext} */
      current_component_context
    );
    (context.e ?? (context.e = [])).push(effect2);
  }
  return effect2;
}
function user_root_effect(fn) {
  const effect2 = render_effect(fn, current_block, true);
  return () => {
    destroy_signal(effect2);
  };
}
function effect(fn) {
  return internal_create_effect(EFFECT, fn, false, current_block, true);
}
function managed_effect(fn) {
  return internal_create_effect(EFFECT | MANAGED, fn, false, current_block, true);
}
function managed_pre_effect(fn, sync) {
  return internal_create_effect(PRE_EFFECT | MANAGED, fn, sync, current_block, true);
}
function pre_effect(fn) {
  if (current_effect === null) {
    throw new Error(
      "ERR_SVELTE_ORPHAN_EFFECT" + (DEV ? ": The Svelte $effect.pre rune can only be used during component initialisation." : "")
    );
  }
  const sync = current_effect !== null && (current_effect.f & RENDER_EFFECT) !== 0;
  return internal_create_effect(
    PRE_EFFECT,
    () => {
      const val = fn();
      flush_local_render_effects();
      return val;
    },
    sync,
    current_block,
    true
  );
}
function invalidate_effect(fn) {
  return internal_create_effect(PRE_EFFECT, fn, true, current_block, true);
}
function render_effect(fn, block = current_block, managed = false, sync = true) {
  let flags = RENDER_EFFECT;
  if (managed) {
    flags |= MANAGED;
  }
  return internal_create_effect(
    flags,
    /** @type {any} */
    fn,
    sync,
    block,
    true
  );
}
function derived(fn) {
  const is_unowned = current_effect === null;
  const flags = is_unowned ? DERIVED | UNOWNED : DERIVED;
  const signal = (
    /** @type {import('../types.js').ComputationSignal<V>} */
    create_computation_signal(flags | CLEAN, UNINITIALIZED, current_block)
  );
  signal.i = fn;
  signal.e = default_equals;
  if (current_consumer !== null) {
    push_reference(current_consumer, signal);
  }
  return signal;
}
function derived_safe_equal(fn) {
  const signal = derived(fn);
  signal.e = safe_equal;
  return signal;
}

// node_modules/svelte/src/constants.js
var EACH_ITEM_REACTIVE = 1;
var EACH_INDEX_REACTIVE = 1 << 1;
var EACH_KEYED = 1 << 2;
var EACH_IS_CONTROLLED = 1 << 3;
var EACH_IS_ANIMATED = 1 << 4;
var EACH_IS_STRICT_EQUALS = 1 << 6;
var PROPS_IS_IMMUTABLE = 1;
var PROPS_IS_RUNES = 1 << 1;
var PROPS_IS_UPDATED = 1 << 2;
var PROPS_IS_LAZY_INITIAL = 1 << 3;
var DelegatedEvents = [
  "beforeinput",
  "click",
  "dblclick",
  "contextmenu",
  "focusin",
  "focusout",
  // 'input', This conflicts with bind:input
  "keydown",
  "keyup",
  "mousedown",
  "mousemove",
  "mouseout",
  "mouseover",
  "mouseup",
  "pointerdown",
  "pointermove",
  "pointerout",
  "pointerover",
  "pointerup",
  "touchend",
  "touchmove",
  "touchstart"
];
var PassiveDelegatedEvents = ["touchstart", "touchmove", "touchend"];
var AttributeAliases = {
  // no `class: 'className'` because we handle that separately
  formnovalidate: "formNoValidate",
  ismap: "isMap",
  nomodule: "noModule",
  playsinline: "playsInline",
  readonly: "readOnly"
};
var DOMBooleanAttributes = [
  "allowfullscreen",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "disabled",
  "formnovalidate",
  "hidden",
  "indeterminate",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "seamless",
  "selected"
];
var namespace_svg = "http://www.w3.org/2000/svg";
var interactive_elements = /* @__PURE__ */ new Set([
  "a",
  "button",
  "iframe",
  "embed",
  "select",
  "textarea"
]);
var disallowed_parapgraph_contents = [
  "address",
  "article",
  "aside",
  "blockquote",
  "details",
  "div",
  "dl",
  "fieldset",
  "figcapture",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "hr",
  "menu",
  "nav",
  "ol",
  "pre",
  "section",
  "table",
  "ul"
];
var implied_end_tags = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"];
function is_tag_valid_with_parent(tag, parent_tag) {
  switch (parent_tag) {
    case "select":
      return tag === "option" || tag === "optgroup" || tag === "#text";
    case "optgroup":
      return tag === "option" || tag === "#text";
    case "option":
      return tag === "#text";
    case "tr":
      return tag === "th" || tag === "td" || tag === "style" || tag === "script" || tag === "template";
    case "tbody":
    case "thead":
    case "tfoot":
      return tag === "tr" || tag === "style" || tag === "script" || tag === "template";
    case "colgroup":
      return tag === "col" || tag === "template";
    case "table":
      return tag === "caption" || tag === "colgroup" || tag === "tbody" || tag === "tfoot" || tag === "thead" || tag === "style" || tag === "script" || tag === "template";
    case "head":
      return tag === "base" || tag === "basefont" || tag === "bgsound" || tag === "link" || tag === "meta" || tag === "title" || tag === "noscript" || tag === "noframes" || tag === "style" || tag === "script" || tag === "template";
    case "html":
      return tag === "head" || tag === "body" || tag === "frameset";
    case "frameset":
      return tag === "frame";
    case "#document":
      return tag === "html";
  }
  switch (tag) {
    case "h1":
    case "h2":
    case "h3":
    case "h4":
    case "h5":
    case "h6":
      return parent_tag !== "h1" && parent_tag !== "h2" && parent_tag !== "h3" && parent_tag !== "h4" && parent_tag !== "h5" && parent_tag !== "h6";
    case "rp":
    case "rt":
      return implied_end_tags.indexOf(parent_tag) === -1;
    case "body":
    case "caption":
    case "col":
    case "colgroup":
    case "frameset":
    case "frame":
    case "head":
    case "html":
    case "tbody":
    case "td":
    case "tfoot":
    case "th":
    case "thead":
    case "tr":
      return parent_tag == null;
  }
  return true;
}

// node_modules/svelte/src/internal/client/validate.js
var void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;
function is_void(tag) {
  return void_element_names.test(tag) || tag.toLowerCase() === "!doctype";
}
function validate_store(store, name) {
  if (store != null && typeof store.subscribe !== "function") {
    throw new Error(`'${name}' is not a store with a 'subscribe' method`);
  }
}
function validate_dynamic_component(component_fn) {
  const error_message = "this={...} of <svelte:component> should specify a Svelte component.";
  try {
    const instance = component_fn();
    if (instance !== void 0 && typeof instance !== "object") {
      throw new Error(error_message);
    }
    return instance;
  } catch (err) {
    const { message } = (
      /** @type {Error} */
      err
    );
    if (typeof message === "string" && message.indexOf("is not a function") !== -1) {
      throw new Error(error_message);
    } else {
      throw err;
    }
  }
}
function validate_void_dynamic_element(tag_fn) {
  const tag = tag_fn();
  if (tag && is_void(tag)) {
    console.warn(`<svelte:element this="${tag}"> is self-closing and cannot have content.`);
  }
}
function validate_dynamic_element_tag(tag_fn) {
  const tag = tag_fn();
  const is_string = typeof tag === "string";
  if (tag && !is_string) {
    throw new Error('<svelte:element> expects "this" attribute to be a string.');
  }
}
function validate_each_keys(collection, key_fn) {
  const keys = /* @__PURE__ */ new Map();
  const maybe_array = untrack(() => collection());
  const array = is_array(maybe_array) ? maybe_array : maybe_array == null ? [] : Array.from(maybe_array);
  const length = array.length;
  for (let i = 0; i < length; i++) {
    const key = key_fn(array[i], i);
    if (keys.has(key)) {
      throw new Error(
        `Cannot have duplicate keys in a keyed each: Keys at index ${keys.get(
          key
        )} and ${i} with value '${array[i]}' are duplicates`
      );
    }
    keys.set(key, i);
  }
}
function loop_guard(timeout) {
  const start = Date.now();
  return () => {
    if (Date.now() - start > timeout) {
      throw new Error("Infinite loop detected");
    }
  };
}
var snippet_symbol = Symbol.for("svelte.snippet");
function add_snippet_symbol(fn) {
  fn[snippet_symbol] = true;
  return fn;
}
function validate_snippet(snippet_fn) {
  if (snippet_fn && snippet_fn[snippet_symbol] !== true) {
    throw new Error(
      "The argument to `{@render ...}` must be a snippet function, not a component or some other kind of function. If you want to dynamically render one snippet or another, use `$derived` and pass its result to `{@render ...}`."
    );
  }
  return snippet_fn;
}
function validate_component(component_fn) {
  if ((component_fn == null ? void 0 : component_fn[snippet_symbol]) === true) {
    throw new Error("A snippet must be rendered with `{@render ...}`");
  }
  return component_fn;
}

export {
  is_array,
  array_from,
  object_assign,
  define_property,
  get_descriptor,
  get_descriptors,
  is_function,
  default_equals,
  safe_not_equal,
  safe_equal,
  ROOT_BLOCK,
  IF_BLOCK,
  EACH_BLOCK,
  EACH_ITEM_BLOCK,
  AWAIT_BLOCK,
  KEY_BLOCK,
  HEAD_BLOCK,
  DYNAMIC_COMPONENT_BLOCK,
  DYNAMIC_ELEMENT_BLOCK,
  SNIPPET_BLOCK,
  UNINITIALIZED,
  push_reference,
  effect_active,
  user_effect,
  user_root_effect,
  effect,
  managed_effect,
  managed_pre_effect,
  pre_effect,
  invalidate_effect,
  render_effect,
  derived,
  derived_safe_equal,
  get_stack,
  mark_module_start,
  mark_module_end,
  add_owner,
  strip_owner,
  check_ownership,
  source,
  mutable_source,
  proxy,
  unstate,
  schedule_task,
  schedule_raf_task,
  current_effect,
  set_ignore_mutation_validation,
  is_signals_recorded,
  inspect_fn,
  current_block,
  current_component_context,
  execute_effect,
  flushSync,
  flush_sync,
  tick,
  get,
  set,
  set_sync,
  invalidate_inner_signals,
  mutate,
  mark_subtree_inert,
  set_signal_value,
  destroy_signal,
  untrack,
  push_destroy_fn,
  getContext,
  setContext,
  hasContext,
  getAllContexts,
  update,
  update_prop,
  update_pre,
  update_pre_prop,
  exclude_from_object,
  value_or_fallback,
  push,
  pop,
  deep_read_state,
  deep_read,
  inspect,
  unwrap2 as unwrap,
  freeze,
  EACH_ITEM_REACTIVE,
  EACH_INDEX_REACTIVE,
  EACH_KEYED,
  EACH_IS_CONTROLLED,
  EACH_IS_ANIMATED,
  EACH_IS_STRICT_EQUALS,
  PROPS_IS_IMMUTABLE,
  PROPS_IS_RUNES,
  PROPS_IS_UPDATED,
  PROPS_IS_LAZY_INITIAL,
  DelegatedEvents,
  PassiveDelegatedEvents,
  AttributeAliases,
  DOMBooleanAttributes,
  namespace_svg,
  interactive_elements,
  disallowed_parapgraph_contents,
  is_tag_valid_with_parent,
  validate_store,
  validate_dynamic_component,
  validate_void_dynamic_element,
  validate_dynamic_element_tag,
  validate_each_keys,
  loop_guard,
  add_snippet_symbol,
  validate_snippet,
  validate_component
};
//# sourceMappingURL=chunk-DVZZ2LBH.js.map
